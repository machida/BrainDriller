ID,drill_title,title,statement,o1,o2,o3,o4,ans,explanation,in_order,tag0,tag1,tag2,tag3,private_memo,drill_id
,Crystal,Crystal,"```crystal
p 'Hello, World!'
```
これをコンパイルしようとすると、以下のようにエラーがでます。なんと言われてますか。
```
syntax error in eval:1
Error: unterminated char literal, use double quotes for strings
```","構文エラー
終わりのない文字リテラル、文字列のためにはダブルクォートを使って","実行時エラー
終わりのない文字リテラル、文字列のためにはダブルクォートを使って","ゼロ除算エラー
0で割っています","構文エラー
型を指定してください",1,"Crystalでは、文字と文字列を区別します。
文字は、1文字と決まっています。",,,,,,,
,Crystal,Crystal,"```crystal
p []
```
これをコンパイルしようとすると、以下のようにエラーがでます。なんと言われてますか。
```crystal
syntax error in eval:1
Error: for empty arrays use '[] of ElementType'
```","構文エラー
終わりのない文字リテラル、文字列のためにはダブルクォートを使って","構文エラー
空配列のために、'[] of  要素の型'を使ってください。","実行時エラー
終わりのない文字リテラル、文字列のためにはダブルクォートを使って","実行時エラー
空配列のために、'[] of  要素の型'を使ってください。",2,"Crystalの配列は、要素の型を決めなければなりません。
これは、空配列を作るときでも、最初に要素の型を明示的に指定する必要があります。

```crystal
a = [] of String
p a.class #=> Array(String)
p typeof(a) #=> Array(String)
```
",,,,,,,
,Crystal,Crystal,"```crystal
a = [""foo"", ""bar"", ""baz""]
b = %w[foo bar baz]

p a == b
```",`true`を返す,`false`を返す,異なるクラスを比べているため、エラーとなる。,配列の初期化時に型の指定がないため、syntax error(構文エラー)となる。,1,文字列の配列を作るとき、%wの%記法が用意されています。,,,,,,,
,Crystal,Crystal,"```crystal
p 'a' == ""a""
```",`true`を返す,`false`を返す,異なるクラスを比べているため、構文エラーとなる。,異なるクラスを比べているため、実行時エラーとなる。,2,文字と文字列は異なるものとして、`false`を返します。,,,,,,,
,Crystal,Crystal,"```crystal
p 1 == 1.0
```",`true`を返す,`false`を返す,異なるクラスを比べているため、構文エラーとなる。,異なるクラスを比べているため、実行時エラーとなる。,1,本問では、Int32とFloat64を比較してますが、`true`を返します。,,,,,,,
,Crystal,Crystal,"```crystal
p 1.class
p 1.0.class
```","```crystal
p 1.class     #=> Int32
p 1.0.class #=> Float32
```","```crystal
p 1.class     #=> Int32
p 1.0.class #=> Float64
```","```crystal
p 1.class     #=> Int64
p 1.0.class #=> Float32
```","```crystal
p 1.class     #=> Int64
p 1.0.class #=> Float64
```",2,整数型では32bit、浮動小数点数型では64bitが一般によく使われると考えられてのことです。,,,,,,,
,Crystal,Crystal,"```crystal
a = [1, 2, 3]
p a.inject{ |s, e| s += e }
```",`6`を返す,`nil`を返す,`nil`と1を足そうとして、エラーになる。,`inject`が定義されてないため、エラーとなる。,4,"Rubyでは`reduce`と`inject`がエイリアスとして存在しています。
しかし、Crystalは、エイリアスを持たない方針で、`reduce`のみです。",,,,,,,
,Crystal,Crystal,"```crystal
p 5 / 2
```",`Int32`の`2`を返す,`Float64`の`2.5`を返す,`Float32`の`2.5`を返す。,`5 / 2`を返す。,2,"Crystalの整数どうしの`/`による商は、浮動小数点数を返します。
`/`で浮動小数点数を返すようにすると、一般的な算数の答えに近い形となり、また`/`という記号で返り値の型が浮動小数点数だと推定できます。

整数型では32bit、浮動小数点数型では64bitが一般によく使われると考えられてのことです。",,,,,,,
,Crystal,Crystal,"```crystal
p nil.to_i
```",`Int32`の`0`を返す,`Float64`の`0.0`を返す,`nil`を返す,エラーとなる,4,"```
Error: undefined method 'to_i' for Nil
```

なお、Rubyでは、`nil.to_i`は`0`となります。",,,,,,,
,Crystal,Crystal,"Crystalには円周率(π)と真の円周率(τ)を表す定数が用意されています。
適切に呼べるものは、どれでしょうか。","```crystal
p Math.PI
p Math.TAU
```","```crystal
p Math:PI
p Math:TAU
```","```crystal
p Math.:PI
p Math.:TAU
```","```crystal
p Math::PI
p Math::TAU
```",4,"定数の呼び方は、コロン`:`を2つ並べます。

なお、`Math`モジュールをトップレベルにインクルードすれば、
トップレベルから直接`PI`を呼び出すことができます。
```crystal
include Math
p PI #=> 3.141592653589793
```

τは、PythonやRustにもある真の円周率です。
数学などで2πがよくでてきて、2πの方が数式を綺麗にシンプルに表せることが多いです。
そのため、πよりも2πを円の定数として置いた方がいいという主張が存在します。",,,,,,,
10,CSS,border,"内側のalertクラスのあるdivタグの枠線は、何色になりますか。

`HTML`
```html
<div class=""black-box"">
   main
  <div class=""alert"">
    アラート
  </div>
  main
</div>
```

`CSS`
```css
.black-box {
  border: solid 1px black;
}

.alert {
 color: red;
 border: solid 1px;
}
```",黒色,赤色,無色,線は存在しない,2,"枠線は、継承されません。
内側の枠線は、borderで色が指定されてないため、colorで指定された色の影響を受けます。colorは、文字色だけでなく、枠線の色にも影響する点に注意してください。",,,,,,,
11,CSS,aタグ,"次のHTMLコード・CSSで誤っている点はどれですか。

```html
<a href=""class"" class=""block"">
  ブロック1
  <a href=""https://example.com"">
    インライン
  </a>
  ブロック2
</a>
```

```css
.block {
  display: block;
}
```",aタグ内でさらにタグを書いている点が誤り。,aタグをブロックにしている点が誤り。,aタグ内にaタグを書いている点が誤り。,誤りは存在しない,3,"HTML5以降では、aタグをブロックとして、aタグ内にタグを含めても問題ありません。
ただし、aタグ内にaタグがあると、HTMLが正しく認識されません。",,,,,,,
,CSS,flex,`flex-flow`は何と何を一括指定するプロパティですか。,`flex-basis`と`flex-grow`,`flex-basis`と`flex-wrap`,`flex-direction`と`flex-grow`,`flex-direction`と`flex-wrap`,4,"`flex-flow`は、`flex-direction`と`flex-wrap`の値を一括指定して流れを決めるプロパティです。
`flex-direction`が方向で、`row`(行方向 = 左から右), `column`(列方向 = 上から下), `row-reverse`, `column-reverse`の4通りを指定します。
`flex-wrap`が、`nowrap`, `wrap`, `wrap-reverse`の3通りです。
4 * 3 で12通りの指定方法があります。",,,,,,,
,CSS,grid,"次のgridは、何行何列のグリッドを作りますか。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px;
}
```",3行2列,2行3列,3行3列,2行2列,2,"columnが列で、rowが行ですね。
最後が複数形になる点に注意です。",,,,,,,
,CSS,grid,gridでは、名前をつける方法がありますが、どのように指定しますか。,grid-template: 100px [t-start] 100px [t-end];,grid-template: 100px [t-starts] 100px [t-ends];,grid-template: 100px [t-begin] 100px [t-end];,grid-template: 100px [t-begins] 100px [t-ends];,1,,,,,,,,
,CSS,color,"`box` クラスの枠線は、何色になりますか。

```css
.box {
  border: 1px solid #eee;
}
```",赤,緑,青,灰色,4,"`#`始まりは、16進数によるRGBの指定となります。
`#eee`は、`#EEE`や`#eeeeee`と同じです。
RGBは、赤(Red)・緑(Green)・青(Blue)の光の三原色のことで、それぞれが混ざった場合により明るい色になります。今回は、白に近い灰色となります。
",,,,,,,
3,HTML,<HTMLタグ>大文字小文字,HTMLタグは、<h1>や<p>などの小文字ですか。<H1>や<P>などの大文字ですか。,小文字,大文字,両方とも動く,,3,HTMLタグは、小文字でも大文字でも動きます。,TRUE,HTMLタグ,HTML,入門,基礎,混ぜても動く?,
4,HTML,<HTMLタグ>改行タグ,"下記のHTMLの文章Aと文章Bに改行を入れるために、???に書くべきタグは何でしょうか。
```html
<div>文章A???文章B</div>
```",<h1>,<p>,<hr>,<br>,4,"改行するタグは、line break(改行)からきている<br>タグです。
「壊す」や「一休み」の意味合いであるbreakが改行をするのは独特な感じがするかもしれませが、
一文を壊したり一休みしたりすると考えると良いでしょう。",FALSE,HTMLタグ,HTML,入門,基礎,,
5,HTML,<HTMLタグ>見出しタグ,横に水平の線を引くHTMLタグは。,<h1>,<p>,<hr>,<br>,3,"<hr>は、horizontal rule(水平な罫線、横型の罫線)を作るタグです。
日本語のルール(Rule)は「(スポーツの)規則・きまり」の意味合いで使われることが多いですが、
ruleには「定規」や「罫線」の意味合いがあります。",FALSE,HTMLタグ,HTML,入門,基礎,,
6,HTML,<HTMLタグ>HTMLの意味,HTMLは何の略?,HighLevel Markup Language,HyperText Markup Language,HighLevel Makeup Language,HyperText Makeup Language,2,"HTMLの最初の説明で必ずといっていいほど書いてありますが、
知らなくても困らないので意外にソラですぐ言える人は多くないかもしれません。
なお、makeupは化粧の意味合いです。",TRUE,HTMLタグ,HTML,雑学,基礎,,
7,HTML,<HTMLタグ>見出しタグ,見出しをつけるタグは,<head>,<header>,<hr>,"<h1>, <h2>, …… ,<h6>",4,<h1> ~ <h6>のhは、heading(見出し)の意味合いです。よく使いますね。,FALSE,HTMLタグ,HTML,雑学,基礎,,
,HTML,title属性,"一般に、title属性が示すものはなんですか。
```html
<a href=""http://example.com"" title=""example.comへのリンク"">example.com<a>
```",補足情報,題名,字幕,称号,1,"titleタグは、ウェブページのタイトルです。
title属性は、一般に補足情報です。",,,,,,,
,JavaScript,Number,"```js
console.log(5 / 2)
```",2,3,2.5,エラーになる,3,"JavaScriptの数値リテラルで作られるNumberという数値データは、浮動小数点数型です。浮動小数点数どうしの割り算の結果は、浮動小数点数になります。

JavaScriptは明示的に数値の型を指定したりしないです。
しかし、とても大事なことなので、JavaScriptの基本的な数値データが、Numberという浮動小数点数であることは知っておくと他言語を習得するに理解が容易になります。",,,,,,,
,JavaScript,BigInt,"```js
console.log(5n / 2n)
```",2,3,2.5,エラーになる,1,"2n, 5nというのは、BigIntという整数値データを作る数値リテラルです。BigIntどうしの`/`による商は、BigIntとなり端数がでるような場合は切り捨てられます。",,,,,,,
,JavaScript,NumberとBigInt,"```js
console.log(5 / 2n)
```",2,3,2.5,エラーになる,4,5はNumberという浮動小数点数のデータ、2nはBigIntという整数データになります。JavaScriptでは、この両者を足したり引いたりできません。,,,,,,,
,JavaScript,文字列の置換,"```js
const str = ""foo-foo-bar""
console.log(str.replace(""foo"", ""bar""))
```",`bar-bar-bar`,`bar-foo-bar`,`foo-foo-foo`,エラーになる,2,,,,,,,,
,JavaScript,文字列の置換,"```js
const str = ""foo-foo-bar""
console.log(str.replace(/foo/g, ""bar""))
```",`bar-bar-bar`,`bar-foo-bar`,`foo-foo-foo`,エラーになる,1,複数の対象を置換したいときは、`/foo/g`と正規表現にして`g`オプションをつけます。,,,,,,,
,JavaScript,falsy,JavaScriptでfalsy(偽に相当)となるデータを列挙したものとして、最も適切なものを選びなさい。,false,"false, nil","false, 0","false, null, undefined, 0, 0n, NaN, [], """"",4,"JavaScriptは、偽となるものが多いですね。

他のプログラミング言語で、例えばRubyだと、偽と判定されるものが`false`と`nil`だけです。
",,,,,,,
,JavaScript,累乗,"```ruby
console.log(5 ** 2 * 2 ** 2)
```",5,100,2500,390625,2,"`**`は累乗の演算子です。
PythonやRubyでも、`**`の演算子として使われています。

問題を数式で表現すると5² x 2² = 100 となり、優先順位が自然でわかりやすいかもしれません。
JavaScriptの計算の優先順位は一般的な算数・数学と同じで、累乗 > 積商 > 和差の順に計算します。",,,,,,,
,JavaScript,累乗,"```ruby
console.log(2 ** 3 ** 2)
```",64,512,構文エラーとなる,実行時エラーとなる,2,"+や-などの一般的な記号は、左から順番に計算されますが、 **は右から計算されます。
これは、数式で表現したときの計算順序に合わせたものです。",,,,,,,
,JavaScript,オブジェクト,"```js
obj = { }
console.log(obj[0])
```",undefinedを返す,nullを返す,nilを返す,エラーになる,1,"nullではなく、undefinedを返します。

nilがあるのは、Rubyなどです。",,,,,,,
,,,,,,,,,,,,,,,,
,JavaScript,,"それぞれ何を返しますか。
```js
console.log(null && true || true)
console.log(true || true && null)
```","true
true","true
false","false
true","false
false",1,"`||`と`&&`の優先順位は、`&&`の方が高いため、`&&`から計算されます。
`null && true`の返り値は、`null`です。
また、`null || true`の返り値は、`true`です。

`(null && true) || true` => `null || true` => `true`
`null || (true && null)` => `true || null` => `true`

なお、C言語やRubyなどでも、`&&`の方が`||`よりも優先的に計算されます。",,,,,,,
,rbenv,rbenv,"`rbenv -v`
このコマンドは、何をする。",rbenv自身のバージョンを表示,現在のRubyバージョン、及び、その指定方法,インストールされているRubyの一覧、実行されるRubyのバージョン、そのバージョンが何で指定されているか,rbenvにそのようなコマンドはないので、エラーになる,1,ショートオプションでは`-v`ですが、ロングオプションで`--version`と指定することも可能です。,,,,,,,
,rbenv,rbenv,"`rbenv versions`
このコマンドは、何をする。",rbenv自身のバージョンを表示,現在のRubyバージョン、及び、その指定方法,インストールされているRubyの一覧、実行されるRubyのバージョン、そのバージョンが何で指定されているか,rbenvにそのようなコマンドはないので、エラーになる,3,"複数形な点に注意してください。
Rubyがrbenvを通じてインストールされてるか等は、このコマンドを実行して確かめられます。
なお、`rbenv --help`で、`rbenv`のもつコマンドと簡単な説明の一覧で確かめられます。",,,,,,,
11,Ruby,Rubyの **,"Rubyで、`5 * 2`は10を返しますが、`5 ** 2`は何でしょう。
```ruby
p 5 * 2  #=> 10
p 5 **2 #=>  ?
```",1,5,10,25,4,"5 ** 2 は、5 の 2 乗であり、5^2 = 25 です。
Python も ** は同様の定義です。",TRUE,四則演算,Ruby,基礎,入門,,
12,Ruby,Rubyの /,Rubyで、`5 * 2`は10を返しますが、`5 / 2`は何でしょう。,1,2,5,10,2,Ruby で整数値同士の割り算は、切捨てて整数を返します。,TRUE,四則演算,Ruby,基礎,入門,,
13,Ruby,Rubyの %,Rubyで、`5 * 2`は10を返しますが、`5 % 2`は何でしょう。,1,2,5,10,1,C言語、Pythonなど多くのメジャーな言語で % は余りを返します。,TRUE,四則演算,Ruby,基礎,入門,,
14,Ruby,Ruby の ** の優先順位,"```ruby
p 5 ** 2 * 2 ** 2
```
Rubyのこのコードを実行するとどうなりますか。",5,100,2500,390625,2,"正解は、100です。
問題を数式で表現すると5² x 2² = 100 となり、優先順位が自然でわかりやすいかもしれません。
Rubyの優先順位は一般的な算数・数学と同じで、累乗 > 積商 > 和差の順に計算します。",TRUE,四則演算,Ruby,基礎,マニアック,,
15,Ruby,Rubyの数値   80,"```ruby
p 80
```
Rubyのこのコードを実行するとどうなりますか。
",80を出力する。,128を出力する。,何も出力せず、正常終了する。,エラーになる。,1,そのまま数値を出力します。,TRUE,四則演算,Ruby,基礎,入門,,
17,Ruby,Rubyの数値 080,"```ruby
p 080
```
Rubyのこのコードを実行するとどうなりますか。",16を出力する,80を出力する。,128を出力する。,エラーになる。,4,"Ruby技術者認定試験 Silverで出題される問題です。
0b始まりは2進数、0始まりは8進数、0x始まりは16進数です。
本問は0始まりで8進数の数値が書かれるはずです。
しかし、8進数は0 ~ 7 の8個の数値のみです。
本問ではそれ以外の数値である8があるため、8進数として認識できずエラーになります。",TRUE,8進法,Ruby,基礎,マニアック,,
18,Ruby,Rubyの数値 0x80,"```ruby
p 0x80
```
Rubyのこのコードを実行するとどうなりますか。
",16を出力する,80を出力する。,128を出力する。,エラーになる。,3,"0b始まりは2進数、0始まりは8進数、0x始まりは16進数です。
0 * 1 + 16 * 8 = 128 となります。",TRUE,16進法,Ruby,基礎,マニアック,,
19,Ruby,Rubyの ?a,"```ruby
p ?a
```
Rubyのこのコードを実行するとどうなりますか。",trueを表示,97を出力(表示)する,aを表示(出力)する。,エラーになる。,3,"1文字の文字列を書く特殊な方法です。
わかりづらいので推奨されないですが、知らないと困るときもあるかもしれません。
Ruby技術者認定試験 Silverで出題される問題ですので、Ruby技術者認定試験 Silverを受ける方は覚えておきましょう。",TRUE,文字列,Ruby,基礎,マニアック,,
20,Ruby,Rubyの _,"```ruby
p 10_0_0_0
```
Rubyのこのコードを実行するとどうなりますか。
",10が出力される。,10000が出力される。,"""10_0_0_0""が表示される。",エラーになる。,2,"人間のための桁区切りの機能です。
例えば、1000000007だとわかりづらいので、コード内で1_000_000_007と書くことができます。
日本社会では、大きな数を3桁ごとにカンマで区切って見やすくすることがありますが、
RubyやPythonでは読みやすさのためにアンダースコアで区切ります。
なお、基本は好きな場所で区切れますが、アンダースコア始まり・アンダースコア終わり・アンダースコア2連続はエラーとなります。
以下は、エラーとなる例です。
```ruby
_100
100_
1__000
```",TRUE,数値,Ruby,基礎,知識,,
,Ruby,underscore,Rubyでは、`_`始まりの変数名を定義することができますか。,,,,,,,,,,,,,
21,Ruby,Rubyの to_i,"```ruby
p nil.to_i
p """".to_i
p ""X"".to_i
```
Rubyのこのコードを実行するとどうなりますか。",最初の行でエラーになる。,"2行目でエラーになる。
(1行目で0が出力される)","3行目でエラーになる。
(1行目, 2行目で0が出力される)",エラーは起きず、すべて0が出力される。,4,"to_i の i とはinteger(整数)型のことで、整数型に変換します。

nil は、0を返します。
また、文字列が数字始まりでなかった場合も0を返します。

余談ですが、Rubyをリスペクトして作られたCrystalにもto_iメソッドがありますが、本問はすべてエラーになります。",TRUE,数値,to_i,Ruby,知識,,
,Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto"", ""Fukuoka""]
p a[1]
```

このRubyのコードを実行するとどうなりますか。","""Tokyo""が出力される。","""Kyoto""が出力される。","""Fukuoka""が出力される。",nilが出力される。,2,"Rubyの配列(Array)は、基本的に0から数えます。
本問では、0番目が`""Tokyo""`, 1番目が`""Kyoto""`の配列なので、`""Kyoto""`を返します。",,,,,,,
,Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto""]
p a[-1]
```

このRubyのコードを実行するとどうなりますか。","""Tokyo""が出力される。","""Kyoto""が出力される。",nilが出力される。,エラーになる。,2,"Rubyでは、配列(Array)に負の添字を用いることができます。
配列の末尾から数えて取り出したいときは、負の添字を用いましょう。
末尾(左)から指定するときは、-1, -2という指定になります。

本問の場合、`-1`を指定しているので、末尾から数えて1番目の`""Kyoto""`を返します。",,,,,,,
,Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto""]
p a[2]
```

このRubyのコードを実行するとどうなりますか。","""Tokyo""が出力される。","""Kyoto""が出力される。",nilが出力される。,エラーになる。,3,"本問の配列(Array)は、左から0番目が`""Tokyo""`, 1番目が`""Kyoto""`で、
添字で指定している2番目は存在しないです。

Rubyの配列は、存在しない添字を指定すると、`nil`を返します。
そのため、本問の正解は、`nil`を出力します。",,,,,,,
,Ruby,RubyのString,"```ruby
p ""dog"".reverse
```

このRubyのコードを実行するとどうなりますか。","""dog""が出力される。","""god""が出力される。",nilが出力される。,エラーになる。,2,"文字列(String)の`reverse`メソッドは反転した文字列を返します。
よって、正解は`""god""`です。

```ruby
p ""dog"".reverse #=> ""god""
```",,,,,,,
,Ruby,Array#sort,"```ruby
a = [3, 1, 2]
a.sort
p a
```

このRubyのコードを実行するとどうなりますか。"," 元の配列のまま、[3, 2, 1]が出力される。","昇順に並び替えられて、[1, 2, 3]が出力される。","降順に並び替えられて、[3, 1, 2]が出力される。",エラーになる。,1,"Arrayの(ブロックなしの)`sort`は、並び替えた新しい配列を返すメソッドです。
破壊的に変更しているわけではなく、`sort`の返り値を使ってないので、本問のコードはおかしなコードです。",,,,,,,
,Ruby,Array#sort!,"```ruby
a = [3, 1, 2]
a.sort!
p a
```

このRubyのコードを実行するとどうなりますか。","元の配列のまま[3, 2, 1]が出力される。","昇順に並び替えられた[1, 2, 3]が出力される。","逆順の[2, 1, 3]が出力される。",エラーになる。,2,"`sort!`は、`sort`と異なり破壊的メソッドです。
`sort!`は、元の配列のオブジェクトを破壊的に変更して、昇順に並び替えます。",,,,,,,
,Ruby,降順ソートできないもの,"```ruby
a = [3, 1, 2]
```

このような数値の配列を降順にソートしたいです。
降順にソートでき**ない**例は、どれでしょうか。","```ruby
a.sort.reverse
```","```ruby
a.sort_by{ |e| -e }
```","```ruby
a.reverse
```","```ruby
a.sort{ |x, y| y <=> x }
```",3,"`reverse`メソッドは、逆順にするメソッドですが、降順にするメソッドではないです。
よって、`reverse`のみコードが、降順にできない選択肢です。",,,,,,,
,Ruby,capitalize,"```ruby
p ""Tokyo"".capitalize
p ""tokyo"".capitalize
p ""TOKYO"".capitalize
```

このRubyのコードを実行するとどうなりますか。","p ""Tokyo"".capitalize #=> ""tokyo""
p ""tokyo"".capitalize #=> ""tokyo""
p ""TOKYO"".capitalize #=> ""tokyo""","p ""Tokyo"".capitalize #=> ""TOKYO""
p ""tokyo"".capitalize #=> ""TOKYO""
p ""TOKYO"".capitalize #=> ""TOKYO""","p ""Tokyo"".capitalize #=> ""Tokyo""
p ""tokyo"".capitalize #=> ""Tokyo""
p ""TOKYO"".capitalize #=> ""Tokyo""
","```ruby
p ""Tokyo"".capitalize #=> ""tOKYO""
p ""tokyo"".capitalize #=> ""TOKYO""
p ""TOKYO"".capitalize #=> ""tokyo""
```",3,"文字列(String)の`capitalize`メソッドは、文字列の最初の文字を大文字にし、残りを小文字で返すメソッドです。

全て大文字にするメソッドは、`upcase`メソッド。
全て小文字にするメソッドは、`downcase`メソッド。
大文字・小文字を入れ替えるメソッドは、`swapcase`メソッドです。",,,,,,,
,Ruby,tally,"```ruby
a = [""Apple"", ""Orange"", ""Banana"", ""Apple"", ""Banana"", ""Apple""]
p a.tally
```

このRubyのコードを実行するとどうなりますか。
【注意】 tallyは、2019年12月リリースのRuby 2.7で使えるよううになったメソッドです。Ruby 2.7以降で実行するものとします。","重複が削除された`[""Apple"", ""Orange"", ""Banana""]`を返す。","それぞれの要素を数えた`{""Apple""=>3, ""Orange""=>1, ""Banana""=>2}`というハッシュを返す。","それぞれの要素を数えた数のみ`[3, 1, 2]`という配列を返す。",エラーになる。,2,"tallyは、聞き慣れない単語かもしれないですね。
日本で「正」の字で数えることがありますが、世界的には「卌」で数え、これをtallyというそうです。

機能的に便利なメソッドですが、メソッド名がなかなか決まらず、導入されたのはRuby 2.7(2019年12月リリース)と比較的遅いです。",,,,,,,
,Ruby,gsub,"```ruby
p ""H33/3/31 - H33/4/1"".gsub(""H33"", ""R2"")
```

このRubyのコードを実行するとどうなりますか。
","`""R2/3/31 - R2/4/1""`が出力される。","`""H33/3/31 - R2/4/1""`が出力される。","`""R2/3/31 - H33/4/1""`が出力される。",エラーになる。,1,"`gsub`メソッドは、第1引数に該当する全てを第2引数に置き換えます。
なお、最初に該当したものだけを置換するときは、`sub`メソッドを用います。",,,,,,,
,Ruby,合計,"```ruby
a = [3, 1, 2]
```

配列の全ての要素の合計を取りたいとき、何を使いますか。",a.size,a.count,a.sum,a.tally,3,"数値が要素の配列の合計を知りたいときは、`sum`メソッドを用います。
```ruby
p [3, 1, 2].sum #=> 6
```

なお、`Array#sum`メソッドは、Ruby2.4(2016年12月リリース)で導入されました。
`sum`メソッドが導入される前は、`inject`(`reduce`)メソッドが用いられていました。

```ruby
p [3, 1, 2].inject(:+) #=> 6
```
",,,,,,,
,Ruby,size,"```ruby
p [].count       # => 0
p ""string"".count # ?
```

このRubyのコードを実行するとどうなりますか。",配列の要素数`0`と文字列の文字数`6`がそれぞれ出力される。,nilと文字列の文字数`6`がそれぞれ出力される。,配列の要素数0が出力されるが、文字列のcountではエラーになる。,1行目でエラーになり、エラー文以外は表示されない。,3,"配列やハッシュの要素数、文字列の長さを数えるときは、`size`や`length`を使います。
配列の場合は`count`でも要素数を求められますが、文字列の`count`は文字を数えるために使います。

```ruby
p 'database'.count('a')  #=> 3
p 'database'.count('ae') #=> 4
```
",,,,,,,
,Ruby,push,"```ruby
a = []
a << 1
a.push(2)
p a
```

このRubyのコードを実行すると、何が出力されますか。",[],[1],[2],"[1, 2]",4,`<<`も`push`も、配列の末尾に要素を追加する破壊的メソッドです。,,,,,,,
,Ruby,pop,"```ruby
a = [30, 90, 45]
p a.pop
p a
```

このRubyのコードの出力として相応しいものはなんですか。","```ruby
a = [30, 90, 45]
p a.pop              #=> 30
p a                  #=> [30,90, 45]
```","```ruby
a = [30, 90, 45]
p a.pop              #=> 45
p a                  #=> [30, 90, 45]
```","```ruby
a = [30, 90, 45]
p a.pop              #=> 30
p a                  #=> [90, 45]
```","```ruby
a = [30, 90, 45]
p a.pop              #=> 45
p a                  #=> [30,90]
```",4,"`Array#pop`は、末尾の要素を取り出す破壊的メソッドです。
",,,,,,,
,Ruby,shift,"```ruby
a = ['x', 'y']
a.push('z')
a.shift
p a
```

このRubyのコードを実行すると、どうなりますか。","['x', 'y']","['x', 'y', 'z']",['y'],"['y', 'z']",4,"`Array#push`は、配列の末尾に要素を追加する破壊的メソッドです。
`Array#shift`は、配列の先頭要素をとりだす破壊的メソッドです。

本問では、末尾に文字列`'z'`が追加され、先頭の文字列`'x'`が取り出されます。

",,,,,,,
,Ruby,concat,"```ruby
a = [1]
a + [2]
a.concat([3])
p a
```

このRubyのコードを実行すると、どうなりますか。",[1],"[1, 2]","[1, 3]","[1, 2, 3]",3,"`+`は、配列どうしを結合させた新しい配列を返します。しかし、破壊的ではないです。
対して、Rubyの`concat`は、レシーバの配列を破壊的に変更して結合させます。


したがって、本問の`a + [2]`は結果的に何もしてないおかしなコードです。
対して、`concat`では、配列`a`に`[3]`が破壊的に結合されます。

なお、JavaScriptの`concat`は、Rubyと異なり破壊的ではないです。",,,,,,,
,Ruby,偽,Rubyで偽(falsy)となるオブジェクトを列挙したものとして正しいのはどれでしょうか。,false,"false, nil","false, 0, 0.0","false, null, undefined, 0, 0n, NaN, [], """"",2,"Rubyで、偽(falsy)となるオブジェクトは、`nil`と`false`のみです。
他言語では`false`以外に`0`や空配列が偽となる言語もありますが、
Rubyで偽(falsy)となるオブジェクトは2つだけなので、覚えやすいです。

```ruby
if 0 && []
  puts ""0も空配列もtruthy""
end
```

なお、4問目の選択肢は、JavaScriptをイメージしており、undefinedやnullといった名称のオブジェクトはRubyに存在しません。",,,,,,,
,Ruby,空配列のmax,"sumメソッドは合計を返すメソッドで、
maxメソッドは最大値を返すメソッドです。

```ruby
p [2, 3, 1].sum #=> 6
p [2, 3, 1].max #=> 3
```

さて、空配列に`sum`メソッドを使うと0を返しますが、
空配列に`max`メソッドを使うとどうなりますか。

```ruby
p [].sum #=> 0
p [].max # ?
```",nilを返す,0を返す,`-Float::INFINITY`を返す,エラーとなる,1,"要素が全て数値のときは最大値を返しますが、空配列のときは`nil`を返すので注意しましょう。
空配列のときに`0`を得たいときは、`||`を用いnilのときに`0`を返すようにするとよいでしょう。
```ruby
p [].max      #=> nil
p [].max || 0 #=> 0
```",,,,,,,
,Ruby,文字列と数値,"`p 1 + ""1""`を実行すると、どうなりますか。",2が出力。,"""11""が出力される。",49が出力される。,エラーとなる。,4,"数値と文字列(数字)は、Rubyでは足し合わせることは出来ずエラーとなります。
なお、JavaScriptの場合、数値と文字列の数字を足そうとすると、
数値が自動的に文字列に変換された上で、文字列同士の結合となります。
",,,,,,,
,Ruby,文字列と数値,"`""a"" * 3`は`""aaa""`を返しますが、`3 * ""a""`はどうなりますか。","`""aaa""`を返す",`Float::NAN`を返す,0を返す,エラーとなる。,4,"```ruby
""a"" * 3 #=> ""aaa""
3 * ""a""
```
前者では`String`の`*`メソッドが呼ばれます。
後者では`Integer`の`*`メソッドが呼ばれます。
`Integer`の`*`メソッドは、数値どうしの掛け算となるよう、
引数の`""a""`をInteger型に変換できないか確かめます。
確かめた結果、変換できないため、`TypeError`となります。",,,,,,,
,Ruby,Hashのキー,"```ruby
h = { name: ""Smith"", age: 20 }
p h[""name""]
```
このコードを実行すると、どうなりますか。","`""Smith""`を出力する","`{ :name => ""Smith""}`を出力する。",`nil`を出力する,エラーになる。,3,"本問のHashのキーはシンボルの`:name`で、文字列`""name""`とは異なるものとされ、Hashから取り出すことはできません。",,,,,,,
,Ruby,Hashのキー,"```ruby
h = { name: ""Smith"", age: 20 }
p h[:name]
```
このコードを実行すると、どうなりますか。","`""Smith""`を出力する","`{ :name => ""Smith""}`を出力する。",`nil`を出力する,エラーになる。,1,"```ruby
h = { :name => ""Smith"", :age => 20 } # 一般的な表記
h = { name: ""Smith"", age: 20 }       # キーがSymbolのときにだけできる短縮表記
```
キーがSymbolのときは後者の短縮表記で書くのが一般的です。",,,,,,,
,Ruby,Array#grep,"```ruby
p ""str"".methods.grep(/each/).sort
```
このコードを実行すると、どうなりますか。",[],[:each],"[:each_byte, :each_char, :each_codepoint, :each_grapheme_cluster, :each_line]",エラーになる。,3,"`""str"".methods`で、この`""str""`オブジェクトで使えるメソッド名の入った配列が返ります。
この配列に`grep(/each/)`があり、正規表現で`each`にひっかるメソッド名のみに絞った配列を返します。

なお、Rubyの`String`に`each`メソッドはありません。
これは、文字で回すものが文字なのか行なのかバイトなのか自明ではないためです。",,,,,,,
,Ruby,putsの返り値,"Rubyのメソッドは何かしらの返り値を返します。
`puts`メソッドも引数の文字を出力する一方で、返り値があります。
下記のコードの`puts`の返り値として`x`には何が代入されますか。

```ruby
x = puts ""Hello, World!""
p x # ?
```","`""Hello, World!""`",`true`,`0`,`nil`,4,ふつう`puts`メソッドの返り値は使わないでしょうが、知っておくといいかもしれません。,,,,,,,
,Ruby,pの返り値,"Rubyのメソッドは何かしらの返り値を返します。
`p`メソッドも引数の文字を出力する一方で、返り値があります。
下記のコードの`p`の返り値として`x`には何が代入されますか。
```ruby
x = p ""Hello, World!""
p x # ?
```","`""Hello, World!""`",`true`,`0`,`nil`,1,"もともと`p`メソッドの返り値は、`puts`と同じ`nil`でした。
しかし、現Rubyコミッタの遠藤さんの提案から、`p`メソッドは出力する引数を返すようになりました。
`p`メソッドを途中で挟んでも返り値を変更しないため、デバッグが容易になりました。",,,,,,,
,Ruby,to_i,"Rubyで`to_i`は、整数値(Integer)に変換するメソッドです。
`""100"".to_i`は、`100`が返りますが、下記のコードはどうなりますか。

```ruby
p ""100\n"".to_i
p ""100a"".to_i
p ""a100"".to_i
```","```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 100
p ""a100"".to_i  #=> 100
```","```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 100
p ""a100"".to_i  #=> 0
```","```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 0
p ""a100"".to_i  #=> 0
```","```ruby
p ""100\n"".to_i #=> 0
p ""100a"".to_i  #=> 0
p ""a100"".to_i  #=> 0
```",2,"`String#to_i`は、文字列の先頭の数値のみを見ます。
文字列の最初が数字でなかったり、空文字列だったりする場合は、`0`を返します。",,,,,,,
,Ruby,to_iの引数,"Rubyで`to_i`は、整数値(Integer)に変換するメソッドです。
引数なしで使われることが多いですが、引数をとることもできます。
下記のコードを実行すると、どうなるでしょう。

```ruby
p ""10"".to_i(2)
p ""20"".to_i(16)
```","```ruby
p ""10"".to_i(2)  #=> 5
p ""20"".to_i(16) #=> 1
```","```ruby
p ""10"".to_i(2)  #=> 20
p ""20"".to_i(16) #=> 320
```","```ruby
p ""10"".to_i(2)  #=> 2
p ""20"".to_i(16) #=> 32
```","```ruby
p ""10"".to_i(2)  #=> 4
p ""20"".to_i(16) #=> 512
```",3,"`""10"".to_i(2)`は`10`を`2`進数表記として解釈して数値変換し、2(=2*1+1*0)となります。
`""20"".to_i(16)`は`20`を`16`進数表記として解釈して数値変換し、32(=16*32+1*0)となります。",,,,,,,
,Ruby,Hash#to_a,"```ruby
h = { name: ""John"", age: 16 }
p h.to_a
```

このコードを実行すると、どうなりますか。","`[:name, ""John"", :age, 16]`が出力","`[[:name, ""John""], [:age, 16]]`が出力",`Enumerator`クラスのインスタンスが出力,エラーになる。,2,`to_a`のaはArray(配列)のaです。,,,,,,,
,Ruby,String#chars,"```ruby
p ""abc"".chars
```
このコードを実行すると、どうなりますか。","`[""a"", ""b"", ""c""]`が出力","""abc""が出力","`[97, 98, 99]`が返る。",エラーになる。,1,"`chars`メソッドは、文字列を1文字の配列にするメソッドです。
なお、`chars`にブロックを渡したとき、`each_char`と同じ挙動となり、1文字ずつ回します。",,,,,,,
,Ruby,Integer#chr,"```ruby
p 97.chr
```
このコードを実行すると、どうなりますか。","`""97""`が出力","`""a""`が出力",NoMethodErrorとなる,RangeErrorとなる,2,"`Integer#chr`は、整数値を文字コードで変換した文字を返します。
""a""の文字コードが97なので、`97.chr`は`""a""`を返します。

",,,,,,,
,Ruby,Hash#keys,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.keys
```
このコードを実行すると、どうなりますか。","`[:A, :B, :AB, :O]`が出力される。","`[40, 20, 10, 30]`が出力される。",何も出力されない。,NoMethodErrorとなる,1,"`Hash#keys`は、ハッシュのキーだけにした配列を返します。
なお、キーを1つずつ回したいときは`Hash#each_key`を使います。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.keys #=> [:A, :B, :AB, :O]
```",,,,,,,
,Ruby,Hash#values,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.values
```
このコードを実行すると、どうなりますか。","`[:A, :B, :AB, :O]`が出力される。","`[40, 20, 10, 30]`が出力される。",何も出力されない。,NoMethodErrorとなる,2,"`Hash#keys`は、ハッシュの値だけにした配列を返します。
なお、値を1つずつ回したいときは`Hash#each_value`を使います。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.values #=> [40, 20, 10, 30]
```",,,,,,,
,Ruby,Hash#length,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.length
```
このコードを実行すると、どうなりますか。",4が出力される。,5が出力される。,8が出力される。,エラーとなる。,4,"`Hash#length`は、ハッシュの要素数を返します。
`length`と`size`はエイリアスで、同じ機能を有しています。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.length #=> 4
```",,,,,,,
,Ruby,max_by,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.max_by{ |k, v| v }
```
このコードを実行すると、どうなりますか。",`{ :A => 40 }`が出力される。,`{ :O => 30 }`が出力される。,"`[:A, 40]`が出力される。","`[:O, 30]`が出力される。",3,"`max_by`は、`Enumerable`モジュールから継承されたメソッドです。
ブロックの最終値が最大となるような、キーと値の配列を返します。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.max_by{ |k, v| v } #=> [:A, 40]
```",,,,,,,
,Ruby,Hash.new,"```ruby
h = Hash.new(0)
p h[:a]
```
このコードを実行すると、どうなりますか。",`nil`を返す。,`0`を返す。,`:a`を出力。,エラーとなる。,2,"`Hash.new`で空ハッシュ`{}`が作られます。
引数をとると、作られる空ハッシュにデフォルト値に引数が設定されます。

```ruby
h = Hash.new(0)
p h[:a] #=> 0
```
本問ではデフォルト値に`0`が設定されたハッシュが作られ、
添字`:a`はキーとして持たないので、デフォルト値の`0`が返されます。",,,,,,,
,Ruby,uniq,"```ruby
a = [""A"", ""B"", ""O"", ""AB"", ""A"", ""B"", ""O"", ""AB"", ""B"", ""AB""]
p a.uniq
```

このコードを実行すると、どうなりますか。
","`[""A"", ""B"", ""O"", ""AB""]`が出力。",`false`を返す。,`nil`を返す。,エラーとなる。,1,"```ruby
a = [""A"", ""B"", ""O"", ""AB"", ""A"", ""B"", ""O"", ""AB"", ""B"", ""AB""]
p a.uniq #=> [""A"", ""B"", ""O"", ""AB""]
```
`uniq`は要素の重複が削除された新しい配列を返します。",,,,,,,
,Ruby,uniq!,"```ruby
a = [""A"", ""B"", ""O"", ""AB""]
p a.uniq!
```

このコードを実行すると、どうなりますか。","`[""A"", ""B"", ""O"", ""AB""]`が出力。",`false`を返す。,`nil`を返す。,エラーとなる。,3,"```ruby
a = [""A"", ""B"", ""O"", ""AB""]
p a.uniq! #=> nil
```

`uniq!`は、`uniq`と異なる点が2つほどあります。
- `uniq!`は、破壊的メソッドで、レシーバ自体の重複を削除する。
- `uniq!`は、元の配列が変更されないとき(要素の重複がないとき)、`nil`を返す。",,,,,,,
,Ruby,uniq!,"```ruby
p 5.even?
```

このコードを実行すると、どうなりますか。",`true`を出力する。,`false`を出力する。,`nil`を出力する。,エラーとなる。,2,"```ruby
p 5.even? #=> false
p 5.odd?   #=> true
```

`even?`は、偶数かどうか判定し、偶数なら`true`, 偶数でないなら`false`を返すメソッドです。
反対に、奇数かどうか判定するメソッドとして、`odd?`メソッドがあります。",,,,,,,
,Ruby,Array#empty?,"```ruby
p [3, 2, 1].empty?
```

このコードを実行すると、どうなりますか。",`true`を出力する。,`false`を出力する。,`nil`を出力する。,エラーとなる。,2,"```ruby
p [3, 1, 2].empty? #=> false
p [].empty?           #=> true
```

`empty?`は、空の配列なら`true`を返し、要素があれば`false`を返します。",,,,,,,
,Ruby,Array#slice,"```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  # ?
p a[1...4] # ?
```

このコードを実行すると、どうなりますか。","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""M"", ""T"", ""W"", ""T""]
p a[1...4] #=> [""M"", ""T"", ""W"", ""T""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""M"", ""T"", ""W"", ""T""]
p a[1...4] #=> [""M"", ""T"", ""W""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T"", ""F""]
```",3,"```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T""]
```

`[1, 4]`は、1番目から4つ取るという意味です。
`1...4`は、点が3つあり、Rubyでは終端を含みません。1番目から3番目をとります。
配列は0から数える点に注意してください。",,,,,,,
,Ruby,数値の桁和,"2の15乗の各桁の和を正しく求められているものはどれでしょうか。
",`(2**15).sum`,`(2**15).digits.sum`,`(2**15).digit_sum`,`(2**15).sum{ |d| d }`,2,"`Integer`クラスに、`sum`や`digit_sum`というメソッドはありません。
`digits`メソッドを使うと、各桁の配列を返します。
一の位が1番左に来ることに注意してください。

```ruby
p 123.digits    #=> [3, 2, 1]
p [1, 2, 3].sum #=> 6
```
",,,,,,,
,Ruby,数値の桁数,2の15乗の桁数を正しく求められているものはどれでしょうか。,`(2**15).sum`,`(2**15).size`,`(2**15).to_s.sum`,`(2**15).to_s.size`,4,"`Integer`クラスに、`sum`というメソッドはありません。
`Integer`クラスに、`size`というメソッドはありますが、桁数を返すメソッドではなく、実装上のバイト数を返すメソッドです。
`Integer`の桁数を求めるには、一度`to_s`で文字列にしてから、`size`(or `length`)メソッドで文字列の長さを数えるとよいです。

```ruby
p 987.to_s     #=> ""987""
p ""987"".size #=> 3
```

ただし、負数を文字列にしてそのまま数えると、マイナス記号`-`も数えてしまうので注意してください。",,,,,,,
,Ruby,swap,"```ruby
a = 3
b = 4
```
Rubyで変数`a`と`b`に代入されているものを交換できる方法を選びなさい。","```ruby
a, b = b, a
```","```ruby
swap(a, b)
```","```ruby
[a, b] = [b, a]
```","```ruby
(a, b) = (b, a)
```",1,"Rubyでは、`a, b = b, a`とすると、変数どうして中身を交換できます。

```ruby
a = 1
b = 2
a, b = b, a
p [a, b] #=> [2, 1]
```

`[a, b] = [b, a]`は、JavaScriptなどの方法。
",,,,,,,
,Ruby,文字列を整数値の配列へ,"`""2 12 30""` → `[2, 12, 30]`

このように、スペース区切りの文字列を整数値の配列に変換できる方法を選びなさい。","```ruby
""2 12 30"".split.map(&:to_i)
```","```ruby
""2 12 30"".split.map &:to_i
```","```ruby
""2 12 30"".split(&:to_i)
```","```ruby
""2 12 30"".split.map{ |e| e.to_i }
```",3,"引数なしの`split`メソッドは、スペースや改行で分割して配列を作ります。

```ruby
""2 12 30"".split #=> [""2"", ""12"", ""30""]
```

配列の全ての要素を文字列から数値に変換する方法として、 `map`で新しく配列を作り直すことがよくあります。
```ruby
[""2"", ""12"", ""30""].map{ |e| e.to_i } #=> [2, 12, 30]
[""2"", ""12"", ""30""].map(&:to_i)       #=> [2, 12, 30]
[""2"", ""12"", ""30""].map &:to_i        #=> [2, 12, 30]
```

Rubyは、一定の条件を満たすと、ブロックを省略した記法で書けます。
また、Rubyのメソッドの引数の丸括弧も、省略できるケースが多いです。",,,,,,,
,Ruby,String#sum,"```ruby
p ""123"".sum
```
このコードを実行すると、どうなりますか。
【ヒント】`""1"".ord`の返り値は、""49""です。",`3`が出力される。,`6`が出力される。,`123`が出力される。,`150`が出力される。,4,"`""1"".ord`とすると、文字としての1の文字コードの数値49が返されます。
String#sumは、文字列の各文字の文字コードの数値の合計を求めて返すメソッドです。

`""1""`の文字コードが`49`で、`""2""`, `""3""`の文字コードがそれぞれ`50`, `51`です。
したがって、これらの合計の`150`を`""123"".sum`は返します。",,,,,,,
,Ruby,chompとchop,"```ruby
p ""foo\n"".chomp
p ""foo"".chomp
p ""foo\n"".chop
p ""foo"".chop
```

これの出力で正しい組み合わせを選びなさい。","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""fo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""fo""
```
","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""foo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""foo""
```","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""foo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""fo""
```","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""fo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""foo""
```",3,"文字列`String`には、`chomp`と`chop`と名前が似ている上に、
機能が似ていて紛らわしいインスタンスメソッドがあります。

`chomp`は、末尾が改行のときのみ、改行を落とした新しい文字列を返します。
`chop`は、末尾が何か関係なく、末尾の1文字を落とした新しい文字列を返します。

よく使われるのは、`chomp`かなと思います。
1行の最後に改行があったときにだけ改行を削除してくれて、便利です。",,,,,,,
,Ruby,String#squeeze,"`""foo     bar          baz""` => `""foo bar baz""`
上記のように連続する半角スペースを1文字にできる方法はどれでしょうか。

圧縮したい文字列は、以下のように変数`str`に入っているものとします。
```ruby
str = ""foo     bar          baz""
```",`str.delete(' ')`,"`str.sub(/ +/, "" "")`",`str.squeeze`,"`str.squeeze("" "")`",4,"各選択肢は、以下のような結果となります。
```ruby
str = ""foo     bar          baz""
p str.delete("" "")    #=> ""foobarbaz""
p str.sub(/ +/, "" "") #=> ""foo bar          baz""
p str.squeeze          #=> ""fo bar baz""
p str.squeeze("" "")   #=> ""foo bar baz""
```

`delete("" "")`は、引数の半角スペースを全て削除してしまいます。
`sub(/ +/, "" "")`は、正規表現で連続した半角スペースを指定して置換しますが、置換する対象は1つのみです。`gsub`メソッドであれば、全ての連続する半角スペースにマッチして、置換します。
`str.squeeze`は、引数がないため半角スペースに限らず、全ての連続する文字を1文字に圧縮しています。
`str.squeeze("" "")`は、本問の正解で、引数で半角スペースのみを指定して、半角スペースのみを圧縮しています。

なお、squeezeという英単語は、「(スポンジやレモン等を)握りつぶして絞る」イメージです。",,,,,,,
,Ruby,Hash#invert,"```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert
p colors
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
p colors        #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
p colors        #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
p colors        #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
p colors        #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
```",2,"知ってるか、知らないかの知識問題かなと思います。

`Hash#invert`は、ハッシュのキーと値を反転させるメソッドです。
破壊的メソッドではないので、新しく反転させたハッシュを作り変えしますが、レシーバは元のまま変わりません。

`invert`という英単語は、「反転(させる)」という意味です。

",,,,,,,
,Ruby,Array#to_s,"`[1, 2, 3]` => `""1 2 3""`
上記のように、整数値の配列を、スペース区切りにした文字列にしたいです。","```ruby
[1, 2, 3].to_s
```","```ruby
[1, 2, 3].to_s("" "")
```","```ruby
[1, 2, 3].join
```","```ruby
[1, 2, 3].join("" "")
```",4,"文字列を配列にするときは`split`がよく用いられ
配列を文字列にするときは`join`がよく用いられます。

```ruby
p [1, 2, 3].to_s         #=> ""[1, 2, 3]""
p [1, 2, 3].join         #=> ""123""
p [1, 2, 3].join("" "")  #=> ""1 2 3""
p [1, 2, 3].join("", "") #=> ""1, 2, 3""
```

なお、選択肢の`[1, 2, 3].to_s("" "")`を実行すると、`Array#to_s`に引数を指定する方法はないので`ArgumentError`となります。",,,,,,,
,Ruby,全角の数字,"`""１２３"".to_i`
このような全角の数字の文字列に`to_i`メソッドを使うとどうなるでしょうか。",0が返される。,123が返される。,nilが返される。,エラーとなる。,1,"`String#to_i`は、先頭の文字が、半角の数字以外だと0を返します。

```ruby
p ""abc"".to_i   #=> 0
p ""１２３"".to_i #=> 0
```

数字のように見えても全角の数字は、Rubyだと数字の扱いを受けないので注意しましょう。
",,,,,,,
,Ruby,全角スペース,"```ruby
p ""1 2 3"".split  # ?
p ""4　5　6"".split # ?
```

上の文字列は半角スペースで区切られていますが、
下の文字列は全角スペースで区切られています。
このコードを実行すると、どうなりますか。","```ruby
p ""1 2 3"".split  #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split #=> [""4"", ""5"", ""6""]
```
","```ruby
p ""1 2 3"".split   #=> [1, 2, 3]
p ""4　5　6"".split #=> [4, 5, 6]
```
","```ruby
p ""1 2 3"".split   #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split #=> [""4　5　6""]
```
","```ruby
p ""1 2 3"".split   #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split # エラーになる。
```",3,`String#split`は、引数を指定しないと半角スペースや改行で分割して配列を作りますが、全角スペースでは分割しないようです。,,,,,,,
,Ruby,Hash#map,"```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.map{ |k, v| [v, k] }
```

このコードを実行すると、どうなりますか。","`[[""#fff"", :white], [""#f00"", :red], [""#00f"", :blue]]`を出力する。","`{""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}`を出力する。",ブロックの最終値はハッシュを作る必要があるが、配列を作っているので、TypeErrorという例外をだす。,Hashにmapメソッドはないので、NoMethodErrorという例外をだす。,1,`Array#map`でも、`Hash#map`でも、配列(Array)を作って返すメソッドです。,,,,,,,
,Ruby,String#end_with?,"```ruby
p ""icon1.png"".end_with?("".png"")
p ""icon2.gif"".end_with?("".png"")
```

このコードを実行すると、どうなりますか。","```ruby
p ""icon1.png"".end_with?("".png"") #=> true
p ""icon2.gif"".end_with?("".png"") #=> true
```","```ruby
p ""icon1.png"".end_with?("".png"") #=> true
p ""icon2.gif"".end_with?("".png"") #=> false
```","```ruby
p ""icon1.png"".end_with?("".png"") #=> false
p ""icon2.gif"".end_with?("".png"") #=> true
```","```ruby
p ""icon1.png"".end_with?("".png"") #=> false
p ""icon2.gif"".end_with?("".png"") #=> false
```",2,"知らなくても、メソッド名からある程度の想像はできるのかな、と思います。
`String#end_with?`は、文字列があるパターンで終わっているかどうかを調べます。
反対に先頭を調べるメソッドとして、`start_with?`メソッドも存在します。",,,,,,,
,Ruby,prime?,"```ruby
require ""prime""
p 2.prime? # ?
p 3.prime? # ?
p 4.prime? # ?
```

このコードを実行すると、どうなりますか。","```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> true
p 4.prime? #=> true
```","```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> true
p 4.prime? #=> false
```","```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> false
p 4.prime? #=> false
```","```ruby
require ""prime""
p 2.prime? #=> false
p 3.prime? #=> false
p 4.prime? #=> false
```",2,"`require ""prime""`で、`prime`ライブラリがロードされ、
`Integer#prime?`が拡張されるなど、素数周りの機能が使えるようになります。

`Integer#prime?`は、素数かどうか判定して、真偽値を返すメソッドです。

【補足】
素数は、1より大きい自然数の中で、正の約数が1と自分自身のみの数です。
2や3は1と自分自身のみを正の約数として持つので、素数です。
4は、1と自分自身の他に2を正の約数として持つので、素数ではありません。",,,,,,,
,Ruby,clear,次の選択肢の中で、エラーとなるものはどれでしょうか。,"```ruby 
a = [1, 2, 3]
a.clear
p a #=> []
```","```ruby 
h = {white: ""fff"", black: ""000""}
h.clear
p h #=> {}
```","```ruby 
s = ""string""
s.clear
p s #=> """"
```","```ruby
i = 1
i.clear
p i #=> 0
```",4,"Array, Hash, Stringには、破壊的に空にする`clear`メソッドがあります。
しかし、Integerに、そのようなメソッドはありませんし、破壊的メソッドがありません。",,,,,,,
,Ruby,エイリアスの多いメソッド,`Hash#key?`のエイリアスで**ない**メソッドは、どれでしょう。,`include?`,`member?`,`has_key?`,`have_key?`,4,"Rubyコアの中で、エイリアスが多いメソッドです。最多でしょうか?
Rubyコアでメソッド名の中の動詞は原形で使われていることが多いですが、`has_key?`や`has_value`は珍しく三単現(三人称・単数形・現在形)です。

【注意】
`Hash#key?`というメソッドの他に、`Hash#key`という別のメソッドもあるので注意してください。

【補足：原形のメソッド】
原形のメソッドとして,`Array#include?`や`String#start_with?`などがあります。
Rubyの生みの親のMatzさん自身は、原形で統一したいと考えているようです。
なお、`puts`は、「put」と「string」が由来で、三単現ではありません。",,,,,,,
,Ruby,文字列が要素の配列,"`[""月"", ""火"", ""水"", ""木"", ""金"", ""土"", ""日""]`という配列を作れる%記法は、次のうちどれ。",`%i[月 火 水 木 金 土 日]`,`%q[月 火 水 木 金 土 日]`,`%s[月 火 水 木 金 土 日]`,`%w[月 火 水 木 金 土 日]`,4,"```ruby
p %i[月 火 水 木 金 土 日] #=> [:月, :火, :水, :木, :金, :土, :日]
p %w[月 火 水 木 金 土 日] #=> [""月"", ""火"", ""水"", ""木"", ""金"", ""土"", ""日""]
```

%wの記法による文字列が要素の配列の生成は、`,`や`""`を書かなくて済むので、見た目が少しスッキリします。",,,,,,,
,Ruby,Range#to_a,"`(0...5).to_a`は、`[0, 1, 2, 3, 4]`の連番の配列を作ります。
これと異なる配列を作るものは、次のうちどれでしょう。",`[*0...5]`,`[*(0..4)]`,`[0..4]`,`5.times.to_a`,3,"`[0..4]`は、`0..4`という`Range`クラスのインスタンスが1要素としてある配列です。
",,,,,,,
,Ruby,each_cons,"```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a
p a.each_cons(3).to_a
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, nil, nil]]
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=>  [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]
```",4,"`each_slice(3)`とすると、要素数3の幅で区切っていきます。
`each_cons(3)`とすると、要素数3の幅で1つずつスライドしていきます。",,,,,,,
,Ruby,each,"```ruby
(0...5).each do |i|
  p i
end
```
0から4まで順番に出力します。
これと異なる出力をするものは、どれでしょうか。","```ruby
(0...5).each do |i|
  p i
end
```","```ruby
0.upto(4) do |i|
  p i
end
```","```ruby
[0, 1, 2, 3, 4].each do |i|
  p i
end
```","```ruby
""01234"".each_char do |i|
  p i
end
```",4,"`each_char`(or `chars`)は、文字列をの文字を1文字ずつ回すメソッドであり、
これを使う選択肢のみ文字で回しており、他は整数値で回しています。",,,,,,,
,Ruby,object_id,"```ruby
a = [1, 2, 3]
b = a

a << 4
b.push(5)

p a # ?
p b # ?
```","```ruby
p a #=> [1, 2, 3]
p b #=> [1, 2, 3]
```","```ruby
p a #=> [1, 2, 3, 4]
p b #=> [1, 2, 3, 5]
```","```ruby
p a #=> [1, 2, 3, 4]
p b #=> [1, 2, 3, 4]
```","```ruby
p a #=> [1, 2, 3, 4, 5]
p b #=> [1, 2, 3, 4, 5]
```",4,"`b = a`で同じオブジェクトIDが代入され、変数`a`も`b`も同じ配列を参照することになります。
また、`<<`も`push`も要素を追加する破壊的メソッドです。
どちらの追加でも、全く同じ配列に対して破壊的に要素を追加しており、`a`から見ても`b`から見ても同じ結果を返します。",,,,,,,
,Ruby,Array#*,"```ruby
p [0] * 5
p [1] * 5
p [] * 5
```
","```ruby
p [0] * 5 #=> [0]
p [1] * 5 #=> [5]
p [] * 5  #=> []
```
","```ruby
p [0] * 5 #=> [0]
p [1] * 5 #=> [5]
p [] * 5  #=> [nil]
```","```ruby
p [0] * 5 #=> [0, 0, 0, 0, 0]
p [1] * 5 #=> [1, 1, 1, 1, 1]
p [] * 5  #=> []
```","```ruby
p [0] * 5 #=> [0, 0, 0, 0, 0]
p [1] * 5 #=> [1, 1, 1, 1, 1]
p [] * 5  #=> [nil, nil, nil, nil, nil]
```",3,"文字列に対して整数値(Integer)を乗じたときと同じような挙動ですね。

```ruby
""a"" * 3 #=> ""aaa""
"""" * 3  #=> """"
```",,,,,,,
,Ruby,do~endと{~}の違い,"```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #  ?
p a.map do |e| e * 3 end # ?
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> [9, 3, 6]
p a.map do |e| e * 3 end #=> [9, 3, 6]
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> [9, 3, 6]
p a.map do |e| e * 3 end #=> #<Enumerator: [3, 1, 2]:map>
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> #<Enumerator: [3, 1, 2]:map>
p a.map do |e| e * 3 end #=> [9, 3, 6]
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> #<Enumerator: [3, 1, 2]:map>
p a.map do |e| e * 3 end #=> #<Enumerator: [3, 1, 2]:map>
```",2,"Rubyのあらゆるメソッドは、ブロックを使う機能がなかったとしても、ブロックを取ることができます。
```ruby
p(""Hello, World""){ ""unused block"" }
5.+(4){ ""unused block"" }
```

そして、2つのメソッドが連続していて丸括弧を書かなかったときに、`do ~ end`と`{ ~ }`で、ブロックがどちらのメソッドに紐づくかパースの仕方が変わってきます。

```ruby
p(a.map { |e| e * 3 })
p(a.map)do |e| e * 3 end
```

`{ ~ }`のブロックは内側のメソッドと紐づきますが、`do ~ end`のブロックだと外側のメソッドと紐づきます。

",,,,,,,
,Ruby,範囲外,"```ruby
a = []
a[2] = ""x""
p a
```","`[""x"", ""x"", ""x""]`が出力される。
","`[nil, nil, ""x""]`が出力される。","`[""x""]`が出力される。",`index 2 too large for array; minimum: nil (IndexError)`というエラーが起きる。,2,"配列の要素数を超えた位置(正の数)に要素をセットしようとすると、配列が拡張され、拡張される部分は`nil`で埋められます。

4番目の選択肢は、負の数で範囲を超えたときに起こるエラーを真似したものです。",,,,,,,
,Ruby,範囲外,"```ruby
a = []
a[-1]
a[-2] = ""x""
p a
```",`[]`が出力される。,"`[""x""]`が出力される。",2行目の`a[-1]`で、IndexErrorとなる。,"2行目の`a[-1]`は問題ないが、3行目の`a[-2] = ""x""`でIndexErrorとなる。",4,ゲッターのときは配列の範囲外を参照しても`nil`を返しますが、セッターのときは負の値だとエラーとなります。,,,,,,,
,Ruby,デフォルトProc,"`Array`, `String`, `Hash`の親クラスは`Object`ですが、同様に`Object`の親クラスを調べるとどうなりますか。

```ruby
p Array.superclass  #=> Object
p String.superclass #=> Object
p Hash.superclass   #=> Object
p Object.superclass # ?
```",`Object`の親クラスは存在しないので、`nil`が返る。,`Object`の親クラスは存在しないので、エラーとなる。,`Object`の親クラスの`Object`自分自身であり、`Object`が返る。,`Object`の親クラスの`BasicObject`が返る。,4,多くのクラスの親は`Object`であり、`Object`が基本の土台となるクラスですが、機能を少なくすることで自由度の高いクラスを用意するために`Object`の親に機能が最低限の`BasicObject`クラスが存在します。,,,,,,,
,Ruby,Arrayのnil,配列の`nil`を取り除いた配列を返すメソッドは何でしょうか。,squeeze,strip,uniq,compact,4,"squeezeは、Stringの連続した部分を1文字に潰すメソッド。
stripは、Stringの左右の無駄なスペースを削除するメソッド。
uniqは、Arrayの重複している要素を削除するメソッド。
compactが、本問の答えで、Arrayのnilを削除するメソッド。",,,,,,,
,Ruby,シフト演算子,"`Integer`クラスの`<`は比較演算子と呼ばれるメソッドですが、
`<<`はシフト演算子と呼ばれるメソッドです。
記号の数も違い(=名前が違い)、機能が全くの別物です。

以下のコードの実行結果はどうなるでしょうか。
```ruby
i = 1
p i << 1
p i << 2
p i << 3
p i
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 8
p i << 3 #=> 64
p i      #=> 64
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 4
p i << 3 #=> 8
p i      #=> 1
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 4
p i << 3 #=> 7
p i      #=> 7
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 3
p i << 3 #=> 4
p i      #=> 1
```",2,"Rubyで、Integerのような数値のクラスのインスタンスは、イミュータブルで変更不可能で、破壊的メソッドはなく、基本的に`=`や`+=`のような代入などによって別のオブジェクトに書き換えられない限り、変わることはありません。

今回のケースでは、Integerに`<<`を使っても破壊的メソッドではないので、変数`i`は書き換わらず、常に変数に`1`が代入されたままです。
`<<`はシフト演算子で、`i << n`は`i`を`n`乗した値を返します。",,,,,,,
,Ruby,シフト演算子,"以下のコードを実行したときの最後の出力の結果はどうなりますか。
```ruby
i = 1
a = []

i << 1
a << 1
a.push(2)

p i
p a
```","```ruby
p i  #=> 1
p a  #=> []
```","```ruby
p i  #=> 2
p a  #=> []
```","```ruby
p i  #=> 1
p a  #=> [1, 2]
```","```rubh
p i  #=> 2
p a  #=> [1, 2]
```",3,"`Integer`クラスの`<<`はシフト演算子と呼ばれるメソッドで、`i << n`は`i`の`n`乗を返します。しかし、`Integer`クラスは変更不可能(イミュータブル)なクラスであり、破壊的メソッドはなく、メソッドのレシーバに影響を及ぼすことはありません。

対して、`Array`クラスの`<<`は、末尾に要素を追加する破壊的メソッドです。`push`も`<<`と同様の機能で、末尾に要素を追加する破壊的メソッドです。

結果的に、本問では、`Integer`クラスの変更はないですが、`Array`クラスは変更なされます。",,,,,,,
,Ruby,object_id,"以下のコードを実行したときの最後の出力の結果はどうなりますか。
```ruby
n1 = 1
n2 = 1

a1 = []
a2 = []

p n1.object_id == n2.object_id
p a1.object_id == a2.object_id
```","```ruby
p n1.object_id == n2.object_id #=> true
p a1.object_id == a2.object_id #=> true
```","```ruby
p n1.object_id == n2.object_id #=> true
p a1.object_id == a2.object_id #=> false
```","```ruby
p n1.object_id == n2.object_id #=> false
p a1.object_id == a2.object_id #=> true
```","```ruby
p n1.object_id == n2.object_id #=> false
p a1.object_id == a2.object_id #=> false
```",1,"ミュータブルなオブジェクトには破壊的メソッドがあり、破壊的メソッドを使うとレシーバ自身のオブジェクトの中身を破壊的に変更する可能性があります。
イミュータブルなオブジェクトに破壊的メソッドがなく、オブジェクトの中身が変わることがありません。イミュータブルなオブジェクトは、中身が同じであれば、オブジェクトIDも等しくなります。

【変更可能(ミュータブル)】配列、ハッシュ、文字列など
【変更不可能(イミュータブル)】`true`, `false`, `nil`, 数値, シンボル",,,,,,,
,Ruby,定数,Rubyの定数について、誤っているものを選びなさい。,定数名は大文字始まりです。,定数は、再代入できます。,定数に、再代入すると警告がでます。,定数は、メソッド内で動的に代入することができます。,4,"プログラミング言語で定数といったときに再代入や変更できないようなものを意味しますが、Rubyの定数は、警告(warning)がでるものの、再代入できてしまいます。

```ruby
CONST = 1
CONST = 2
# Main.rb:2: warning: already initialized constant CONST
# Main.rb:1: warning: previous definition of CONST was here
```

ただし、メソッド内で動的に定数を定義するようなことはできません。

```ruby
def foo
  CONST = 2
end
# Main.rb:5: dynamic constant assignment
#  CONST = 2
#   ^~~~~
```",,,,,,,
,Ruby,定数,"下記のコードを実行すると、何が出力されますか。

```ruby
class Foo
end
Bar = Foo

p Foo.new.class
p Bar.new.class
```","```ruby
p Foo.new.class #=> Foo
p Bar.new.class #=> Bar
```","```ruby
p Foo.new.class #=> Foo
p Bar.new.class #=> Foo
```","```ruby
p Foo.new.class #=> Bar
p Bar.new.class #=> Bar
```","```ruby
p Foo.new.class #=> Bar
p Bar.new.class #=> Foo
```",2,"```ruby
class Foo
end
```

上記のように書くと、`Foo`クラスが定義され、定数`Foo`は`Class`クラスのインスタンスとなります。`Bar = Foo`とすることで、定数`Bar`にも全く同じインスタンスが代入され、結果的に`Bar`は`Foo`のエイリアスとなります。
",,,,,,,
,Ruby,freeze,"```ruby
str = ""foo"".freeze
str.upcase!
p str
```","""foo""が表示される。","""Foo""が表示される。","""FOO""が表示される。",FrozenErrorが発生する。,4,"`upcase!`は、文字列を大文字にする破壊的メソッドです。
しかし、本問では、`freeze`が使われ、文字列が`frozen`(凍結=変更不可能)な状態になっています。そのため、変更不可能な文字列に破壊的変更を加えようとした結果、FrozenErrorが発生します。",,,,,,,
,Ruby,freeze,"```ruby
bloods = [""a"", ""b"", ""ab"", ""o""].freeze
bloods.each(&:upcase!)
p bloods
```","`[""a"", ""b"", ""ab"", ""o""]`が表示される。","`[""A"", ""B"", ""AB"", ""O""]`が表示される。","下記のようなエラーとなる。
```
Main.rb:2:in `upcase!': can't modify frozen String: ""a"" (FrozenError)
```","下記のようなエラーとなる。
```
Main.rb:2:in `<main>': undefined method `upcase!' for String: ""a"" (NoMethodError)`
```",2,本問でfreezeされているのは配列であり、中身の文字列までfreezeされているわけではありません。配列に対して`reverse!`や`sort!`のような破壊的メソッドで破壊的に変更することはできませんが、要素としての配列はfreezeされてないので`upcase!`で大文字にすることができます。,,,,,,,
,Ruby,Arrayのエイリアス,Arrayのインスタンスメソッドの中で、エイリアスで**ない**組み合わせを選びなさい。,"sample, suffle","map, collect","push, append","unshift, prepend",1,"sampleはランダムに要素を選ぶメソッドで、shuffleはランダムに要素を並び替えるメソッドで、別の機能です。
mapとcollectは、比較的昔からあるエイリアスです。
対して、appendとprependは、Ruby 2.5(2017年12月リリース)で、元からあったpushとunshiftに追加される形で出来たエイリアスです。",,,,,,,
,Ruby,Arrayのエイリアス,Arrayのインスタンスメソッドの中で、説明が誤っているものを選びなさい。,pushは末尾に要素を追加する破壊的メソッドで、popは末尾から要素を出す破壊的メソッド。,shiftは先頭に要素を追加する破壊的メソッドで、unshiftは先頭から要素を出す破壊的メソッド。,appendは、Ruby2.5でpushのエイリアスとして追加された破壊的メソッド。,prependは、Ruby2.5でunshiftのエイリアスとして追加された破壊的メソッド。,2,unshiftが配列の先頭に要素を追加するメソッドで、shiftが配列の要素をだすメソッドです。,,,,,,,
,Ruby,Mathモジュール,Mathモジュール内の円周率を表す定数の呼び出し方として正しいものを選びなさい。,`Math.PI`,`Math:PI`,`Math.:PI`,`Math::PI`,4,"モジュール内の定数を呼ぶときは、`::`です。
なお、`Math`モジュールをインクルードすれば、そのまま定数を呼び出せます。

```ruby
include Math
p PI
```

",,,,,,,
,Ruby,累乗演算子の優先順位,2 ** 3 ** 2,64,512,SyntaxErrorとなる,NoMethodErrorとなる,2,"+や-などの一般的な記号は、左から順番に計算されますが、 **は右から計算されます。
これは、数式で表現したときの計算順序に合わせたものです。",,,,,,,
,Ruby,String,"文字列の先頭に(破壊的に)追加するメソッドは、`prepend`です。

```ruby
str = ""bar""
str.prepend(""foo"")
p str #=> ""foobar""
```

さて、文字列の末尾に追加でき**ない**方法はどれでしょうか。

```ruby
str = ""foo""
```

変数`str`の末尾に`""bar""`を追加して`""foobar""`にします。","`str += ""bar'`","`str << ""bar'`","`str.append(""bar')`","str.concat(""bar')",3,"配列の方には要素の追加に`append`と`prepend`の両方があります。
しかし、文字列の方は`prepend`はあるものの`append`はありません。

`<<`と`concat`は破壊的メソッドですが、`+=`は新しく結合させて作ったものを再代入しているという違いがあるので、注意しましょう。`+=`の方は破壊的に変更しない代わりに、とても遅くなる可能性があります。
",,,,,,,
,Ruby,attr_reader,"```ruby
class User
  attr_reader :name
end

p User.new.name
```",`nil`が表示される。,NameErrorとなる。,NoMethodErrorとなる。,TypeErrorとなる。,1,"`attr_reader`は、メソッドを作るメソッドです。
本問では、`atrr_reader :name`で、下記のメソッドを作っています。

```ruby
def name
  @name
end
```

ここで、`User.new.name`とすると、`name`インスタンスメソッドが呼び出され、`@name`インスタンス変数が参照されますが、まだ代入されてない変数です。
未定義のローカル変数の場合はエラーとなりますが、このように代入されてないインスタンス変数は`nil`を返します。",,,,,,,
,Ruby,block_given?,"```ruby
def foo
  if block_given?
    p ""With block!""
  else
    p ""Without block!""
  end
end

foo
```","`""With block!""`が表示される。","`""Without block!""`が表示される。",ArgumentErrorとなる。,NoMethodErrorとなる。,2,"`block_given?`は、メソッドにブロックが与えられているかどうか判定するメソッドです。
本問で、`foo`メソッド呼び出しする時にブロックが与えられてないので、`block_given?`は`false`となり、`""Without block!""`が表示されます。
なお、`foo{}`などのように呼び出せば、`block_given?`が`true`になります。

`block_given?`は、定義するメソッドでブロックの有無で動作を変更するような場合に使います。",,,,,,,
,Ruby,Class,"`Class`クラスが継承している親クラスはなんでしょうか。
```ruby
p Class.superclass #=> ?
```",`Object`,`BasicObject`,`Class`,`Module`,4,"`Class`クラスは、`Module`クラスを継承しているクラスです。
なお、クラスとモジュールの違いとして、クラスはインスタンスを作ったり継承できる等の違いがあります。",,,,,,,
,Ruby,Module,"`Module`クラスが継承している親クラスはなんでしょうか。
```ruby
p Module.superclass #=> ?
```",`Object`,`BasicObject`,`Class`,`Module`,1,"`Module`は、`Object`クラスを継承しているクラスです。
なお、`Module`を継承しているクラスとして、`Class`クラスがあります。",,,,,,,
,Ruby,Module,"以下のコードを実行すると、どうなるでしょう。
```ruby
h = { A: 25, B: 25, AB: 25, O: 25 }
p h.invert
```","`{25=>:A, 25=>:B, 25=>:AB, 25=>:O}`と表示される。",`{25=>:A}`と表示される。,`{25=>:O}`と表示される。,エラーとなる,3,"Hashのキーは重複することはありません。
`invert`はキーと値を反転させたハッシュを作るメソッドですが、キーとなる値が重複していた場合、最後のキーが値として反転したときに残ります。

実際のところ、値が重複するようなケースで`invert`を使ってしまうと情報が失われてしまうので、使わない方がいいと思われる。",,,,,,,
,Ruby,比較のメソッド,`object_id`が同じかどうか調べるメソッドはどれですか。,`==`,`===`,`eql?`,`equal?`,4,"基本的に使うのは`==`で、知識問題という感じがします。

`x.equal?(y)`は、`x.object_id == y.object_id`と同じと考えられます。
`[].equal?([])`でも`false`を返すので、最も等号が成り立つ条件が厳しいと考えられます。",,,,,,,
,Ruby,===,"`===`はcase文の中で使われてる演算子(メソッド)です。
`==`は使っても、通常`===`は明示的に使いません。

さて、次のコードを実行すると、どうなりますか。
```ruby
p [] === []
p Array === []
p [] === Array
```

【ヒント】`String === ""str""`は`true`を返します。","```ruby
p [] === []      #=> true
p Array === [] #=> true
p [] === Array #=> true
```","```ruby
p [] === []      #=> true
p Array === [] #=> true
p [] === Array #=> false
```","```ruby
p [] === []      #=> true
p Array === [] #=> false
p [] === Array #=> false
```","```ruby
p [] === []      #=> false
p Array === [] #=> false
p [] === Array #=> false
```",1,"case文の中で`===`は使われています。
```ruby
a = []
case a
  when Array
    ""Array""
  else
    ""Not Array""
  end
end
```",,,,,,,
,Ruby,三項演算子,"```ruby
cond = true
puts cond ? ""Yes"" : ""No""
```","`""Yes""`と表示される。","`""No""`と表示される。",SyntaxErrorとなる。,NoMethodErrorとなる。,1,三項演算子です。簡易な条件分岐で用いられます。,,,,,,,
,Ruby,三項演算子,"```ruby
a = [1, 2, 3]
puts a.empty ? ""Yes"" : ""No""
```","`""Yes""`と表示される。","`""No""`と表示される。",SyntaxErrorとなる。,NoMethodErrorとなる。,4,配列に`empty?`メソッドはありますが、`empty`メソッドはないので、`NoMethodError`となります。,,,,,,,
,Ruby,String#delete,"```ruby
s = ""abcdef""
s.delete(""b-d"")
s.delete!(""c-e"")
p s
```","`""abf""`が表示される。","`""abdf""`が表示される。",SyntaxErrorとなる。,NoMethodErrorとなる。,1,"`Array`や`Hash`の`delete`メソッドは破壊的メソッドです。
一方で、`String`には`delete`と`delete!`があり、`delete!`が破壊的メソッドです。
`String#delete!`の引数で`""c-e""`とすると、`c`から`e`までの文字が削除されます。
",,,,,,,
,Ruby,Hash#delete,"`Array`の`delete`メソッドは、次の挙動をします。
```ruby
a = [:x, :y, :z, :w]
a.delete(:a)
a.delete(:y)
p a #=> [:x, :z, :w]
```

`Hash`の`delete`メソッドについて、次のコードはどうなりますか。
```ruby
h = {0 => 1, 1 => 2, 10 => 1024}
h.delete(1)
h.delete(10)
p h
```","`{0=>1, 1=>2, 10=>1024}`","`{0=>1, 10=>1024}`",`{10=>1024}`,エラーとなる,2,"Arrayが添字ではなく要素を指定して削除して詰める。
対して、Hashは値を指定削除するのかなと思いきや、キーを指定して削除する。`Hash#delete`は、`Array#delete`より`Array#delete_at`に近いような気もする。

あまり使うメソッドではない気がするが、Ruby技術者認定試験Silverあたりにはでるかもしれないので、追加した。",,,,,,,
,Ruby,Array#delete,"```ruby
a = [0, 2, 4, 6, 8, 10, 0, 2, 4]
a.delete_at(4)
a.delete(2)
p a
```","`[0, 4, 6, 10, 0, 2, 4]`","`[0, 4, 8, 10, 0, 4]`","`[0, 2, 6, 10, 0, 2]`","`[0, 4, 6, 10, 0, 4]`",4,"`Array#delete`も`Array#delete_at`も破壊的メソッドです。

 `delete_at(4)`なので、左から4番目の8を削除します。
※0始まりで数えることに注意してください。

次に、`delete(2)`で、要素が`2`のものを全て削除します。",,,,,,,
,Ruby,Range#to_a,`p ('a'..'c').to_a`を実行すると、どうなりますか。,"`[""a"", ""b"", ""c""]`を出力する","`[""a""..""c""]`を出力する。","`[""a"", ""b""]`を出力する。",エラーとなる。,1,"`(1..3).to_a`が`[1, 2, 3]`となるように、
`('a'..'c').to_a`は`[""a"", ""b"", ""c""]`となります。",,,,,,,
,Ruby,配列の注意点,"```ruby
a = ['xyz'] * 3
a[0].tr!(""x-z"", ""a-c"")
p a
```","`[""abc"", ""xyz"", ""xyz""]`","`[""ayc"", ""xyz"", ""xyz""]`","`[""abc"", ""abc"", ""abc""]`","`[""ayc"", ""ayc"", ""ayc""]`",1,"次の方法で、配列の中身を同じ要素にすると、オブジェクトIDが全く同じ要素となります。
```ruby
a = [""xyz""] * 3
p a[0].object_id == a[1].object_id #=> true
```
オブジェクトIDが同じ要素に対して、破壊的変更を加えると、同じオブジェクトを見てるので、他の要素が変わります。",,,,,,,
,Ruby,tr,"```ruby
p ""GTATGC"".tr(""ATCG"", ""TAGC"")
```","`""GTTAGC""`","`""CATACG""`","`""GTATGC""`","`""CATAGC""`",2,"`tr`は文字列内の文字をスワップさせるときに便利です。
本問では、`A`と`T`を入れ替え、`G`と`C`を入れ替えています。",,,,,,,
,Ruby,String#reverse,"`""evil"".reverse`は何を返しますか","""EVIL""","""Evil""","""live""","""evil""",3,`reverse`は文字通り逆転させるメソッドです,,,,,,,
,Ruby,?1,`p ?1`,`1`が出力される。,"`""1""`が出力される。",`49`が出力される。,SyntaxErrorとなる,2,"`""a""`や`""1""`のような1文字の文字列は、文字リテラルという表記で`?a`や`?1`と書くことができます。

なお、Ruby 1.8以前では、`?1`で文字コードの数値49を返していました。",,,,,,,
,Ruby,puts,"以下のコードを実行すると、どうなりますか。
```ruby
class User
  def initialize(first, last)
    @first = first
    @last = last
  end

  def to_s
    ""#{@first} #{@last}""
  end
end

puts User.new(""Abraham"", ""Lincoln"")
```",`#<User:0x0000000001f621a0>` と出力される。,`Abraham Lincoln`と出力される。,NoMethodErrorとなる。,TypeErrorが起きる,2,"ほとんどのオブジェクトは、Object#to_sを継承しているか、`to_s`が再定義されており、`to_s`を持ちます。
そして、putsの内部では, 基本的に`to_s`が実行され、その返り値を利用します。
本問では、`to_s`で文字列を返すように再定義されており、その返り値の文字列を出力します。",,,,,,,
,Ruby,ローカル変数,"```ruby
if false
  foo = ""never""
end

p foo
```",`nil`を出力する。,SyntaxErrorとなる,NameErrorとなる,NoMethodErrorとなる,1,"本問のコードはif文の条件式が`false`で`foo`に代入されることはありません。
しかし、たとえ、実行されなくても、ローカル変数に代入する文があれば、ローカル変数が宣言されたことになり代入前に`nil`を返すようになっています。",,,,,,,
,Ruby,Date,"```ruby
require ""date""

today = Date.today

puts today.sunday? #=> true
puts today.friday?   # ?
```

上記のコードで`today.sunday?`が`true`を返しましたが、`today.friday?`はどうなりますか?",`true`を返す,`false`を返す,`nil`を返す,NoMethodErrorとなる。,2,"`Date.today`は、今日の日付を返すクラスメソッド(特異メソッド)です。

Dateクラスにはそれぞれの曜日を判定するメソッドが用意されています。
いまコードで日曜日かの判定で`true`を返しているので、金曜日かの判定では`false`を返します。",,,,,,,
,Ruby,Date,"```ruby
require ""date""

puts Date.new(2025, 4, 1) + 1
```",2026-04-01,2025-05-01,2025-04-02,NoMethodError,3,日数として足します,,,,,,,
,Ruby,reduce,"```ruby
[].reduce(1, 2, 3)
```

このコードを実行すると、次のようなエラー文が表示されます。

```
Main.rb:1:in `reduce': wrong number of arguments (given 3, expected 0..2) (ArgumentError)
	from Main.rb:1:in `<main>'
```

このエラー文の意味として、相応しいものを選びなさい。",`reduce`というメソッドは存在しない。,`reduce`メソッドの引数の数が誤っている(引数に3が与えられた、期待は0から2だった),`reduce`メソッドの引数の数が誤っている(引数が3個与えられたが、期待している個数は0個から2個だった),`reduce`メソッドの引数の数が誤っている(引数が3個与えられたが、期待している個数は0個から1個だった),3,単純なエラー文ですね,,,,,,,
,Ruby,Array#zip,"```ruby
p [1, 2].zip([:a, :b, :c])
p [1, 2, 3].zip([:a, :b])```","```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [2, :b]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [2, :b]]
```","```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [2, :b]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [2, :b], [3, nil]]
```","```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [1, :b], [1, :c], [2, :a], [2, :b], [2, :c]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [1, :b], [2, :a], [2, :b], [3, :a], [3, :b]]
```",エラーになる,2,zipが、ジッパー(ファスナー)で締めるという意味の英単語です。,,,,,,,
,Ruby,Array#product,"```ruby
p [1, 2].product([:a, :b])
```","`[[1, :a], [2, :b]]`","`[[1, :a], [1, :b], [2, :a], [2, :b]]`",TypeErrorになる,NoMethodErrorになる,2,productは積という意味です。集合どうしの積を求めています。,,,,,,,
,Ruby,Hash#except,"```ruby
h = { name: ""Hara"", age: 20, score: 90 }
p h.except(:name, :address)
p h
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> {:name=>""Hara""}
p h #=> {:age=>20, :score=>0}
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> {:age=>20, :score=>0}
p h #=> {:name=>""Hara"", :age=>20, :score=>0}
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> [""Hara"", nil]
p h #=> {:age=>20, :score=>0}
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> [""Hara"", nil]
p h #=> {:name=>""Hara"", :age=>20, :score=>0}
```",2,"Rails(のActiveSupport)にあった機能ですが、
Ruby 3.0(2020年12月リリース)でRubyコアに組み込まれました。

Hash#deleteを使えば、引数にキーをとって破壊的に削除できましたが、破壊的に削除してしまうので、元の形のまま再利用できませんでした。",,,,,,,
,Ruby,ancestors,"`Object`クラスの親クラス(`superclass`)は、`BasicObject`です。
さて、下記のコードを実行すると、どうなりますか。
```ruby
p Object.ancestors
```",`[BasicObject]`,"`[Object, BasicObject]`","`[Kernel, BasicObject]`","`[Object, Kernel, BasicObject]`",4,,,,,,,,
,Ruby,super,"```ruby
class ParentCounter
  def initialize
    @cnt = 0
  end

  def count
    @cnt += 1
  end
end

class ChildCounter < ParentCounter
  def count
    super
    @cnt += 1
  end
end

counter = ChildCounter.new
p counter.count
```",0,1,2,エラーとなる,3,,,,,,,,
,Ruby,Date,今日の日付を知る方法として、選択肢の中から最も適切なものはどれでしょうか。,"```ruby
require ""date""
Date.new
```","```ruby
require ""date""
Date.now
```","```ruby
require ""date""
Date.today
```","```ruby
require ""date""
Date.commercial
```",3,"今日の日付を知りたいとき、`Date.today`を用います。
`now`クラスメソッドがあるのは、`DateTime`クラスや`Time`クラスです。",,,,,,,
,Ruby,定数探索,"```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST
    p Foo::CONST
    p ::CONST
    p ::Foo::CONST
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 1
    p ::CONST        #=> 2
    p ::Foo::CONST #=> 0
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 2
    p ::CONST        #=> 2
    p ::Foo::CONST #=> 0
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 2
    p ::CONST        #=> 0
    p ::Foo::CONST #=> 1
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 0
    p Foo::CONST #=> 1
    p ::CONST        #=>  2
    p ::Foo::CONST #=> 2
  end
end
```",3,"いま、`::CONST`に`0`, `::Foo::CONST`に`1`, `::Foo::Foo::CONST`に`2`が代入されます。
`::`始まりはトップレベルを指しており、絶対参照のようなものです。
`Foo`が2つある点に注意してください。
トップレベルで定義される`Foo`と、その中で定義される`Foo`です。

単に`CONST`と書かれている場合、自分の階層から順に探していくので、`2`を返します。
次に`Foo::CONST`で、`Foo`自身も定数として、内側の階層から探し、`Foo::Foo`が見つかるので、その中の`CONST`定数を探し、`2`を返します。",,,,,,,
,Ruby,$0と__FILE__,"いま、`main.rb`と`sub.rb`が同一のホームディレクトリ`/Users/aya`にあります。

`main.rb`では、`sub.rb`を実行(ロード)するだけです。
```ruby
require_relative ""./sub""
```

`sub.rb`で出力します。何が出力されますか。
```ruby
p $0
p __FILE__
```

なお、同一のホームディレクトリからコマンドを実行するものとします。","```ruby
p $0          #=> ""main.rb""
p __FILE__ #=> ""main.rb""
```","```ruby
p $0          #=> ""main.rb""
p __FILE__ #=> ""/User/aya/sub.rb""
```","```ruby
p $0          #=> ""/User/aya/sub.rb""
p __FILE__ #=> ""/User/aya/sub.rb""
```",エラーとなる。,2,,,,,,,,
,Ruby,,9の987654321乗を1000000007で割った余りを求める方法として適切なものはどれでしょうか。,`9 ** 987654321 % 1000000007`,"`pow(9, 98765432, 1000000007)`","`9.pow(98765432, 1000000007)`",`9.pow(98765432) % 1000000007`,3,"xのy乗を求めるとき、`x ** y`か`x.pow(y)`と書きます。
さらに、このようなxのy乗をmで割った余りを求めるときは、`x.pow(y, m)`と書きます。

`x ** y % m`と`x.pow(y) % m`と書いて実行すると、累乗の計算の段階で巨大な数となり計算結果が`Float::INFINITY`等になり、`%`で割ることで",,,,,,,
,Rubyで競プロ,ようかんの各長さ(差分),"競プロ典型90問

下記の設問の答えとして誤っているものはどれか。

ようかんの長さがLです。
切れ目がN個あり、0 < d_1 < d_2 < d_3 < d_N < L で与えられます。
全ての箇所で切ったときの、N + 1個のようかんのそれぞれの長さを求めなさい。

L = 34
d = [8, 13, 26]
","```rb
d << L
d.unshift(0)
p d.each_cons(2).map{ |x, y| y - x }
```","```rb
d.push(L)
d.unshift(0)
p d.each_cons(2).map{ _2 - _1 }
```","```rb
d << L
s = 0
d.map{ t = s;  s = _1; _1 - t }
```","```rb
d.push(L)
d.unshift(0)
d.each_slice(2).map{ _2 - _1 }
```",4,each_consを使わない方法がちょっと速いかもしれない。,,,,,,,
,Rubyで競プロ,,,,,,,,,,,,,,,
99,日商簿記,株式会社の設立,"ある株式会社は設立にあたり1株当り50円で株式を100株発行し、出資者より現金を受け取った。発行額の全額を資本金とする。
改題(日商簿記3級サンプル問題、2018 年 10 月）","資本金5,000円 / 現金5,000円","現金5,000円 / 資本金5,000円","有価証券5,000円 / 資本金5,000円",仕訳しない,2,TRUE,資本金,簿記3級,簿記,簡単,,,
8,算数,【算数】2の11乗は,2^{11}を求めて下さい。,256,512,"1,024","2,048",4,"2^{10} = 1024 ≒ 10^3 は有名なので、覚えておくと良いでしょう。
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128
2^8 = 256
2^9 = 512
2^{10} = 1024",TRUE,,算数,数学,基礎,,
9,算数,【算数】和,1 + 2 + 3 + …… + 10 を求めて下さい。,25,35,45,55,4,( 1 + 10 ) \times 10 / 2 = 55,TRUE,数列,算数,数学,基礎,,
10,算数,【算数】素因数分解,360を素因数分解して下さい。,2^3 \times 3^2,2^3 \times 3^3,2^2 \times 3^2 \times 5,2^3 \times 3^2 \times 5,4,"素因数分解とは、ある数を素数の積の形で表すことです。
360は、10で割れることがすぐにわかると思います。
360
= 36 \times 10
= 36 \times 2 \times 5
= 4 \times 9 \times 2 \times 5
= 2^3 \times 3^2 \times 5",TRUE,素因数分解,算数,数学,基礎,,
,英単語,,水曜日,Wensday,Wednsday,Wenesday,Wednesday,4,カタカナ表記のウェンズデイと、実際のスペルがだいぶズレてる感じがありますね。,,,,,,,
,英単語,,火曜日,Tuesday,Thursday,Saturday,Sunday,1,,,,,,,,
,英単語,,木曜日,Tuesday,Thursday,Saturday,Sunday,2,,,,,,,,
,英単語,,土曜日,Tuesday,Thursday,Saturday,Sunday,3,,,,,,,,
,英単語,,日曜日,Tuesday,Thursday,Saturday,Sunday,4,,,,,,,,
1,雑学,日本一の高い山は,日本一の高い山は?,富士山,北岳,奥穂高岳,間ノ岳,1,"富士山は3776mと日本一高いです。
続いて、北岳3193m、奥穂高岳3190m、間ノ岳3190mと並びます。",FALSE,山,日本の山,常識,易しい,,
2,雑学,日本一の低い山は,日本一の高い山は富士山ですが、2番目は?,富士山,北岳,奥穂高岳,間ノ岳,2,"富士山は3776mですが、2番目は北岳3193mです。
続いて、奥穂高岳3190m、間ノ岳3190mと並びます。",FALSE,山,日本の山,雑学,難しい,,
