drill_title,title,statement,correct_option,explanation,zero_based_ans,w1,w2,w3,in_order,tag0,tag1,tag2,tag3,private_memo,drill_id
Ruby,Rubyの **,"Rubyで、`5 * 2`は10を返しますが、`5 ** 2`は何でしょう。
```ruby
p 5 * 2  #=> 10
p 5 **2 #=>  ?
```",25,"`**`は、累乗の演算子です。
`5 ** 2`は、5 の 2 乗、すなわち 5² で`25`を返します。

同様の定義をしている言語は少なくなく、
例として Python や JavaScript などが挙げられます。",3,1,5,10,TRUE,四則演算,Ruby,基礎,入門,,
Ruby,Rubyの /,"Rubyで、`5 * 2`は10を返しますが、`5 / 2`は何でしょう。

ここでは、Integerという整数クラスどうしの割り算です。",2,"Ruby で整数値同士の割り算は、切捨てて整数を返します。

より正確には、Integer どうしの割り算は、Integer を返します。
Floatクラスの整数は、`5.0 / 2.0`は、`2.5`という Float を返します。",1,1,5,10,TRUE,四則演算,Ruby,基礎,入門,,
Ruby,Rubyの %,Rubyで、`5 * 2`は10を返しますが、`5 % 2`は何でしょう。,1,C言語、Pythonなど多くのメジャーな言語で % は余りを返します。,0,2,5,10,TRUE,四則演算,Ruby,基礎,入門,,
Ruby,Ruby の ** の優先順位,"```ruby
p 5 ** 2 * 2 ** 2
```
Rubyのこのコードを実行するとどうなりますか。",100,"正解は、100です。
問題を数式で表現すると5² x 2² = 100 となり、優先順位が自然でわかりやすいかもしれません。
Rubyの優先順位は一般的な算数・数学と同じで、累乗 > 積商 > 和差の順に計算します。",1,5,2500,390625,TRUE,四則演算,Ruby,基礎,マニアック,,
Ruby,Rubyの数値   80,"```ruby
p 80
```
Rubyのこのコードを実行するとどうなりますか。
",80を出力する。,そのまま数値を出力します。,0,128を出力する。,何も出力せず、正常終了する。,エラーになる。,TRUE,四則演算,Ruby,基礎,入門,,
Ruby,Rubyの数値 080,"```ruby
p 080
```
Rubyのこのコードを実行するとどうなりますか。",エラーになる。,"Ruby技術者認定試験 Silverで出題される問題です。
0b始まりは2進数、0始まりは8進数、0x始まりは16進数です。
本問は0始まりで8進数の数値が書かれるはずです。
しかし、8進数は0 ~ 7 の8個の数値のみです。
本問ではそれ以外の数値である8があるため、8進数として認識できずエラーになります。",3,16を出力する,80を出力する。,128を出力する。,TRUE,8進法,Ruby,基礎,マニアック,,
Ruby,Rubyの数値 0x80,"```ruby
p 0x80
```
Rubyのこのコードを実行するとどうなりますか。
",128を出力する。,"0b始まりは2進数、0始まりは8進数、0x始まりは16進数です。
0 * 1 + 16 * 8 = 128 となります。",2,16を出力する,80を出力する。,エラーになる。,TRUE,16進法,Ruby,基礎,マニアック,,
Ruby,Rubyの数値,"classは、オブジェクトのクラスを調べるためのメソッドです。
```ruby
p 10.class
p 10.0.class
p 010.class
```
Rubyのこのコードを実行すると、何が表示されますか。","Integer
Float
Integer","`10`はIntegerクラス、`10.0`はFloatクラスのオブジェクトになります。

`010`のように0始まりのものは、8進数のリテラルです。
`010`は8進数と解釈され、10進数で8を表すIntegerとなります。",1,"Integer
Integer
Integer","Integer
Integer
Hex","Integer
Float
Hex",TRUE,,Ruby,,,,
Ruby,Rubyの数値,"0b始まりは2進数で解釈される整数リテラルです。
```ruby
p 0b11 == 3.0
```
Rubyのこのコードを実行すると、どうなりますか。",trueが表示される,"0b始まりは2進数で解釈される整数リテラルです。
1の位と2の位がそれぞれ1であり、3となります。
Integerクラスの3となります。

3 == 3.0 の比較と同じで、これは true を返します。",1,falseが表示される,SyntaxError,ArgumentError,TRUE,,,,,,
Ruby,Rubyの数値,"```ruby
p 1 + 1.0
p 1.0 + 1
```
Rubyのこのコードを実行すると、何が表示されますか。","2.0
2.0","IntegerとFloatどうしの足し算です。
この場合、Floatを返すようになっています。

【発展】
どちらも同じ結果ですが、
Rubyの`+`はメソッドであり、
左のレシーバーのクラスのメソッドが呼ばれます。
本文の場合、それぞれ`Integer#+`, `Float#+`が呼ばれています。",2,"2
2","2
2.0",ArgumenError,TRUE,,,,,,
Ruby,Rubyの ?a,"```ruby
p ?a
```
Rubyのこのコードを実行するとどうなりますか。",aを表示(出力)する。,"1文字の文字列のためのリテラルです。
ややマイナーなリテラルで推奨されるものではないですが、
いざ出てくると読めなくて困るかもしれません。

Ruby技術者認定試験 Silverで出題される問題ですので、
Ruby技術者認定試験 Silverを受ける方は覚えておきましょう。",2,trueを表示,97を出力(表示)する,エラーになる。,TRUE,文字列,Ruby,基礎,マニアック,,
Ruby,Rubyの _,"```ruby
p 10_0_0_0
```
Rubyのこのコードを実行するとどうなりますか。
",10000が出力される。,"1000000007だとわかりにくいため、
コード上で1_000_000_007とアンダースコアで区切って書くことができます。

日本では読みやすさのために大きな数を3桁ごとにカンマで区切りますが、
RubyやPythonでは読みやすさのためにアンダースコアで区切ります。

なお、基本は好きな場所で区切れますが、アンダースコア始まり・アンダースコア終わり・アンダースコア2連続はエラーとなります。
以下は、エラーとなる例です。
```ruby
_100
100_
1__000
```",1,10が出力される。,"""10_0_0_0""が表示される。",エラーになる。,TRUE,数値,Ruby,基礎,知識,,
Ruby,underscore,Rubyでは、`_`始まりの変数名を定義することができますか。,できる,"Rubyでは、`_`始まりの名前の変数を定義できます。
なんなら、`_`のみの変数も定義できます。
```
_ = 5
p 5 #=> 5
```

実際の使われ方として、使う予定のない不要な返り値を受け取るときに`_`や`_`始まりの変数に代入し、使わないことを示唆するために用いられます。",0,できない,,,,,,,,,
Ruby,Rubyの to_i,"```ruby
p nil.to_i
p """".to_i
p ""X"".to_i
```
Rubyのこのコードを実行するとどうなりますか。",エラーは起きず、すべて0が出力される。,"to_i の i とはinteger(整数)のことで、整数型に変換します。

nil は、0を返します。
また、文字列が数字始まりでなかった場合も0を返します。

【発展】
nil.to_i は、NilClass#to_i が呼ばれ、
その他の文字列からの変換は、String#to_i が呼ばれています。

【余談】
Rubyによく似たCrystalという言語にもto_iメソッドがありますが、
本問はすべてエラーになります。",3,最初の行でエラーになる。,"2行目でエラーになる。
(1行目で0が出力される)","3行目でエラーになる。
(1行目, 2行目で0が出力される)",TRUE,数値,to_i,Ruby,知識,,
Ruby,Rubyの to_i,"```ruby
x = ""10""
y = x.to_i
p [x, y]
```
Rubyのこのコードを実行するとどうなりますか","[""10"", 10]が表示される。","本文の ""10"" は文字列(String)であり、
Stringクラスのインスタンスメソッドのto_iが呼ばれています。
これは、String#to_i と表すのが一般的です。
本文で、""10"".to_i は、Integerクラスの10を返します。",2,"[10, 10]が表示される。","[""10"", ""10""]が表示される。",SyntaxErrorとなる,,,,,,,
Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto"", ""Fukuoka""]
p a[1]
```

このRubyのコードを実行するとどうなりますか。","""Kyoto""が出力される。","Rubyの配列(Array)は、基本的に0から数えます。
本問では、0番目が`""Tokyo""`, 1番目が`""Kyoto""`の配列なので、`""Kyoto""`を返します。",1,"""Tokyo""が出力される。","""Fukuoka""が出力される。",nilが出力される。,,,,,,,
Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto""]
p a[-1]
```

このRubyのコードを実行するとどうなりますか。","""Kyoto""が出力される。","Rubyでは、配列(Array)に負の添字を用いることができます。
配列の末尾から数えて取り出したいときは、負の添字を用いましょう。
末尾(左)から指定するときは、-1, -2という指定になります。

本問の場合、`-1`を指定しているので、末尾から数えて1番目の`""Kyoto""`を返します。",1,"""Tokyo""が出力される。",nilが出力される。,エラーになる。,,,,,,,
Ruby,RubyのArray基本,"```ruby
a = [""Tokyo"", ""Kyoto""]
p a[2]
```

このRubyのコードを実行するとどうなりますか。",nilが出力される。,"本問の配列(Array)は、左から0番目が`""Tokyo""`, 1番目が`""Kyoto""`で、
添字で指定している2番目は存在しないです。

Rubyの配列は、存在しない添字を指定すると、`nil`を返します。
そのため、本問の正解は、`nil`を出力します。",2,"""Tokyo""が出力される。","""Kyoto""が出力される。",エラーになる。,,,,,,,
Ruby,RubyのString,"```ruby
p ""dog"".reverse
```

このRubyのコードを実行するとどうなりますか。","""god""が出力される。","文字列(String)の`reverse`メソッドは反転した文字列を返します。
よって、正解は`""god""`です。

```ruby
p ""dog"".reverse #=> ""god""
```",1,"""dog""が出力される。",nilが出力される。,エラーになる。,,,,,,,
Ruby,Array#sort,"```ruby
a = [3, 1, 2]
a.sort
p a
```
このRubyのコードを実行するとどうなりますか。"," 元の配列のまま、[3, 2, 1]が出力される。","Arrayの(ブロックなしの)`sort`は、並び替えた新しい配列を返すメソッドです。
破壊的に変更しているわけではなく、`sort`の返り値を使ってないので、本問のコードはおかしなコードです。",0,"昇順に並び替えられて、[1, 2, 3]が出力される。","降順に並び替えられて、[3, 1, 2]が出力される。",エラーになる。,,,,,,,
Ruby,Array#sort!,"```ruby
a = [3, 1, 2]
a.sort!
p a
```
このRubyのコードを実行するとどうなりますか。","昇順に並び替えられた[1, 2, 3]が出力される。","`sort!`は、`sort`と異なり破壊的メソッドです。
`sort!`は、元の配列のオブジェクトを破壊的に変更して、昇順に並び替えます。",1,"元の配列のまま[3, 2, 1]が出力される。","逆順の[2, 1, 3]が出力される。",エラーになる。,,,,,,,
Ruby,"
解説者の感覚としては、find, select >> reject >>>>>>>> patition のような頻出・重要度です。","```ruby
p (1..10).partition { |i| i % 3 == 0 }
```","[[3, 6, 9], [1, 2, 4, 5, 7, 8, 10]]","Enumerableモジュールには、find, select, reject, partitionなどのメソッドがあり、
RangeクラスはEnumerableをインクルードしているため、
Raneクラスのインスタンスは、これらのメソッドを使うことができます。
```ruby
p (1..10).find { |i| i % 3 == 0 } # => 3
p (1..10).select { |i| i % 3 == 0 } # => [3, 6, 9]
p (1..10).reject { |i| i % 3 == 0 } # => [1, 2, 4, 5, 7, 8, 10]
p (1..10).partition { |i| i % 3 == 0 } # => [[3, 6, 9], [1, 2, 4, 5, 7, 8, 10]]
```

findは、条件に当てはまる最初の要素を返すメソッドです。
selectは、条件に当てはまる全ての要素を配列に入れて返すメソッドです。
rejectは、条件に当てはまらない全ての要素を配列に入れて返すメソッドです。
partitionは、selectとrejectで得られるのと同じ各配列を入れた配列を返すメソッドです。

解説者の感覚としては、find, select >> reject >>>>>>>> patition のような頻出・重要度です。
partitionは、使う機会も見る機会も、ほとんどないように思います。",3,3,"[3, 6, 9]"," [1, 2, 4, 5, 7, 8, 10]",,,,,,,
Ruby,Enumerableモジュールのエイリアス,Enumerableモジュールのメソッドのエイリアスの組み合わせとして、正しいものを選びなさい,"- map, collect
- find, detect
- select, find_all, fileter
- include?, member?","find, detect は、条件に当てはまる最初の要素を返すメソッドです。
select, find_all, filter は、条件に当てはまる全ての要素を配列にして返すメソッドです。
 
Hash としては include?, has_key?, key?, member? はエイリアスですが、
Enumerble をインクルードするその他のArrayやRange等のクラスにキーの概念はなく、
has_key? や key? のようなエイリアスは存在しないだろうといえます。",2,"- map, collect
- find, find_all
- select, detect, fileter
- include?, member?","- map, collect
- find, find_all
- select, detect, fileter
- include?, has_key?, key?","- map, collect
- find, detect
- select, find_all, fileter
- include?, has_key?, key?",,,,,,,
Ruby,降順ソートできないもの,"```ruby
a = [3, 1, 2]
```
このような数値の配列を降順にソートしたいです。
降順にソートでき**ない**例は、どれでしょうか。","```ruby
a.reverse
```","`reverse`メソッドは、逆順にするメソッドですが、降順にするメソッドではないです。
よって、`reverse`のみコードが、降順にできない選択肢です。",2,"```ruby
a.sort.reverse
```","```ruby
a.sort_by{ |e| -e }
```","```ruby
a.sort{ |x, y| y <=> x }
```",,,,,,,
Ruby,capitalize,"```ruby
p ""Tokyo"".capitalize
p ""tokyo"".capitalize
p ""TOKYO"".capitalize
```

このRubyのコードを実行するとどうなりますか。","p ""Tokyo"".capitalize #=> ""Tokyo""
p ""tokyo"".capitalize #=> ""Tokyo""
p ""TOKYO"".capitalize #=> ""Tokyo""
","文字列(String)の`capitalize`メソッドは、文字列の最初の文字を大文字にし、残りを小文字で返すメソッドです。

全て大文字にするメソッドは、`upcase`メソッド。
全て小文字にするメソッドは、`downcase`メソッド。
大文字・小文字を入れ替えるメソッドは、`swapcase`メソッドです。",2,"p ""Tokyo"".capitalize #=> ""tokyo""
p ""tokyo"".capitalize #=> ""tokyo""
p ""TOKYO"".capitalize #=> ""tokyo""","p ""Tokyo"".capitalize #=> ""TOKYO""
p ""tokyo"".capitalize #=> ""TOKYO""
p ""TOKYO"".capitalize #=> ""TOKYO""","```ruby
p ""Tokyo"".capitalize #=> ""tOKYO""
p ""tokyo"".capitalize #=> ""TOKYO""
p ""TOKYO"".capitalize #=> ""tokyo""
```",,,,,,,
Ruby,tally,"```ruby
a = [""Apple"", ""Orange"", ""Banana"", ""Apple"", ""Banana"", ""Apple""]
p a.tally
```

このRubyのコードを実行するとどうなりますか。
【注意】 tallyは、2019年12月リリースのRuby 2.7で使えるよううになったメソッドです。Ruby 2.7以降で実行するものとします。","それぞれの要素を数えた`{""Apple""=>3, ""Orange""=>1, ""Banana""=>2}`というハッシュを返す。","tallyは、聞き慣れない単語かもしれないですね。
日本で「正」の字で数えることがありますが、世界的には「卌」で数え、これをtallyというそうです。

機能的に便利なメソッドですが、メソッド名がなかなか決まらず、導入されたのはRuby 2.7(2019年12月リリース)と比較的遅いです。",1,"重複が削除された`[""Apple"", ""Orange"", ""Banana""]`を返す。","それぞれの要素を数えた数のみ`[3, 1, 2]`という配列を返す。",エラーになる。,,,,,,,
Ruby,gsub,"```ruby
p ""H33/3/31 - H33/4/1"".gsub(""H33"", ""R2"")
```

このRubyのコードを実行するとどうなりますか。
","`""R2/3/31 - R2/4/1""`が出力される。","`gsub`メソッドは、第1引数に該当する全てを第2引数に置き換えます。
なお、最初に該当したものだけを置換するときは、`sub`メソッドを用います。",0,"`""H33/3/31 - R2/4/1""`が出力される。","`""R2/3/31 - H33/4/1""`が出力される。",エラーになる。,,,,,,,
Ruby,合計,"```ruby
a = [3, 1, 2]
```

配列の全ての要素の合計を取りたいとき、何を使いますか。",a.sum,"数値が要素の配列の合計を知りたいときは、`sum`メソッドを用います。
```ruby
p [3, 1, 2].sum #=> 6
```

なお、`Array#sum`メソッドは、Ruby2.4(2016年12月リリース)で導入されました。
`sum`メソッドが導入される前は、`inject`(`reduce`)メソッドが用いられていました。

```ruby
p [3, 1, 2].inject(:+) #=> 6
```",2,a.size,a.count,a.tally,,,,,,,
Ruby,size,"```ruby
p [].count       # => 0
p ""string"".count # ?
```

このRubyのコードを実行するとどうなりますか。",配列の要素数0が出力されるが、文字列のcountではエラーになる。,"配列やハッシュの要素数、文字列の長さを数えるときは、`size`や`length`を使います。
配列の場合は`count`でも要素数を求められますが、文字列の`count`は文字を数えるために使います。

```ruby
p 'database'.count('a')  #=> 3
p 'database'.count('ae') #=> 4
```
",2,配列の要素数`0`と文字列の文字数`6`がそれぞれ出力される。,nilと文字列の文字数`6`がそれぞれ出力される。,1行目でエラーになり、エラー文以外は表示されない。,,,,,,,
Ruby,push,"```ruby
a = []
a << 1
a.push(2)
p a
```

このRubyのコードを実行すると、何が出力されますか。","[1, 2]",`<<`も`push`も、配列の末尾に要素を追加する破壊的メソッドです。,3,[],[1],[2],,,,,,,
Ruby,pop,"```ruby
a = [30, 90, 45]
p a.pop
p a
```

このRubyのコードの出力として相応しいものはなんですか。","```ruby
a = [30, 90, 45]
p a.pop              #=> 45
p a                  #=> [30,90]
```","`Array#pop`は、末尾の要素を取り出す破壊的メソッドです。
",3,"```ruby
a = [30, 90, 45]
p a.pop              #=> 30
p a                  #=> [30,90, 45]
```","```ruby
a = [30, 90, 45]
p a.pop              #=> 45
p a                  #=> [30, 90, 45]
```","```ruby
a = [30, 90, 45]
p a.pop              #=> 30
p a                  #=> [90, 45]
```",,,,,,,
Ruby,shift,"```ruby
a = ['x', 'y']
a.push('z')
a.shift
p a
```

このRubyのコードを実行すると、どうなりますか。","['y', 'z']","`Array#push`は、配列の末尾に要素を追加する破壊的メソッドです。
`Array#shift`は、配列の先頭要素をとりだす破壊的メソッドです。

本問では、末尾に文字列`'z'`が追加され、先頭の文字列`'x'`が取り出されます。

",3,"['x', 'y']","['x', 'y', 'z']",['y'],,,,,,,
Ruby,concat,"```ruby
a = [1]
a + [2]
a.concat([3])
p a
```

このRubyのコードを実行すると、どうなりますか。","[1, 3]","`+`は、配列どうしを結合させた新しい配列を返します。しかし、破壊的ではないです。
対して、Rubyの`concat`は、レシーバの配列を破壊的に変更して結合させます。

したがって、本問の`a + [2]`は結果的に何もしてないおかしなコードです。
対して、`concat`では、配列`a`に`[3]`が破壊的に結合されます。

なお、JavaScriptの`concat`は、Rubyと異なり破壊的ではないです。",2,[1],"[1, 2]","[1, 2, 3]",,,,,,,
Ruby,偽,Rubyで偽(falsy)となるオブジェクトを列挙したものとして正しいのはどれでしょうか。,"false, nil","Rubyで、偽(falsy)となるオブジェクトは、`nil`と`false`のみです。
他言語では`false`以外に`0`や空配列が偽となる言語もありますが、
Rubyで偽(falsy)となるオブジェクトは2つだけなので、覚えやすいです。

```ruby
if 0 && []
  puts ""0も空配列もtruthy""
end
```

なお、4問目の選択肢は、JavaScriptをイメージしており、undefinedやnullといった名称のオブジェクトはRubyに存在しません。",1,false,"false, 0, 0.0","false, null, undefined, 0, 0n, NaN, [], """"",,,,,,,
Ruby,and と &&,"```ruby
puts ""hello"" and ""world""
puts ""hello"" && ""world""
```","hello
world","and と && の働きは同じですが、優先順位に大きく違いがあります。
and のような英単語の演算子は、優先順位がとても低いです。
そのため、本問では、次のように解釈されます。
```ruby
(puts ""hello"") and (""world"")
puts(""hello"" && ""world"")
```

&&は、両方が真なら、最後に評価される右側を返すため、
本問では ""world"" を返しています。",1,"hello
hello","world
hello","world
world",,,,,,,
Ruby,空配列のmax,"sumメソッドは合計を返すメソッドで、
maxメソッドは最大値を返すメソッドです。

```ruby
p [2, 3, 1].sum #=> 6
p [2, 3, 1].max #=> 3
```

さて、空配列に`sum`メソッドを使うと0を返しますが、
空配列に`max`メソッドを使うとどうなりますか。

```ruby
p [].sum #=> 0
p [].max # ?
```",nilを返す,"要素が全て数値のときは最大値を返しますが、空配列のときは`nil`を返すので注意しましょう。
空配列のときに`0`を得たいときは、`||`を用いnilのときに`0`を返すようにするとよいでしょう。
```ruby
p [].max      #=> nil
p [].max || 0 #=> 0
```",0,0を返す,`-Float::INFINITY`を返す,エラーとなる,,,,,,,
Ruby,文字列と数値,"`p 1 + ""1""`を実行すると、どうなりますか。",エラーとなる。,"数値と文字列(数字)は、Rubyでは足し合わせることは出来ずエラーとなります。
なお、JavaScriptの場合、数値と文字列の数字を足そうとすると、
数値が自動的に文字列に変換された上で、文字列同士の結合となります。
",3,2が出力。,"""11""が出力される。",49が出力される。,,,,,,,
Ruby,文字列と数値,"`""a"" * 3`は`""aaa""`を返しますが、`3 * ""a""`はどうなりますか。",エラーとなる。,"```ruby
""a"" * 3 #=> ""aaa""
3 * ""a""
```
前者では`String`の`*`メソッドが呼ばれます。
後者では`Integer`の`*`メソッドが呼ばれます。
`Integer`の`*`メソッドは、数値どうしの掛け算となるよう、
引数の`""a""`をInteger型に変換できないか確かめます。
確かめた結果、変換できないため、`TypeError`となります。",3,"`""aaa""`を返す",`Float::NAN`を返す,0を返す,,,,,,,
Ruby,Hashのキー,"```ruby
h = { name: ""Smith"", age: 20 }
p h[""name""]
```
このコードを実行すると、どうなりますか。",`nil`を出力する,"本問のHashのキーはシンボルの`:name`で、文字列`""name""`とは異なるものとされ、Hashから取り出すことはできません。",2,"`""Smith""`を出力する","`{ :name => ""Smith""}`を出力する。",エラーになる。,,,,,,,
Ruby,Hashのキー,"```ruby
h = { name: ""Smith"", age: 20 }
p h[:name]
```
このコードを実行すると、どうなりますか。","`""Smith""`を出力する","```ruby
h = { :name => ""Smith"", :age => 20 } # 一般的な表記
h = { name: ""Smith"", age: 20 }       # キーがSymbolのときにだけできる短縮表記
```
キーがSymbolのときは後者の短縮表記で書くのが一般的です。
この短縮表記は、Ruby 1.9(2007/12/25リリース)で導入されました。",0,"`{ :name => ""Smith""}`を出力する。",`nil`を出力する,エラーになる。,,,,,,,
Ruby,Symbol,"```rb
p ""name"" == :name
p :""name"" == :name
```
このコードを実行すると、何が表示されますか。","false
true","文字列(String)とシンボル(Symbol)を == で比較すると、
エラーにはならないですが、必ず false になります。

また、:""name""は、文字列ではなく、シンボルです。
ハイフンや数字の入ったシンボルを使いたいときは、
そのままだと書けないので引用符(クォート)で囲みます。",2,"true
true","true
false","false
false",,,,,,,
Ruby,Array#grep,"```ruby
p ""str"".methods.grep(/each/).sort
```
このコードを実行すると、どうなりますか。","[:each_byte, :each_char, :each_codepoint, :each_grapheme_cluster, :each_line]","`""str"".methods`で、この`""str""`オブジェクトで使えるメソッド名の入った配列が返ります。
この配列に`grep(/each/)`があり、正規表現で`each`にひっかるメソッド名のみに絞った配列を返します。

なお、Rubyの`String`に`each`メソッドはありません。
これは、文字で回すものが文字なのか行なのかバイトなのか自明ではないためです。",2,[],[:each],エラーになる。,,,,,,,
Ruby,putsの返り値,"Rubyのメソッドは何かしらの返り値を返します。
`puts`メソッドも引数の文字を出力する一方で、返り値があります。
下記のコードの`puts`の返り値として`x`には何が代入されますか。

```ruby
x = puts ""Hello, World!""
p x # ?
```",`nil`,ふつう`puts`メソッドの返り値は使わないでしょうが、知っておくといいかもしれません。,3,"`""Hello, World!""`",`true`,`0`,,,,,,,
Ruby,pの返り値,"Rubyのメソッドは何かしらの返り値を返します。
`p`メソッドも引数の文字を出力する一方で、返り値があります。
下記のコードの`p`の返り値として`x`には何が代入されますか。
```ruby
x = p ""Hello, World!""
p x # ?
```","`""Hello, World!""`","もともと`p`メソッドの返り値は、`puts`と同じ`nil`でした。
しかし、現Rubyコミッタの遠藤さんの提案から、`p`メソッドは出力する引数を返すようになりました。
`p`メソッドを途中で挟んでも返り値を変更しないため、デバッグが容易になりました。",0,`true`,`0`,`nil`,,,,,,,
Ruby,to_i,"Rubyで`to_i`は、整数値(Integer)に変換するメソッドです。
`""100"".to_i`は、`100`が返りますが、下記のコードはどうなりますか。

```ruby
p ""100\n"".to_i
p ""100a"".to_i
p ""a100"".to_i
```","```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 100
p ""a100"".to_i  #=> 0
```","`String#to_i`は、文字列の先頭の数値のみを見ます。
文字列の最初が数字でなかったり、空文字列だったりする場合は、`0`を返します。",1,"```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 100
p ""a100"".to_i  #=> 100
```","```ruby
p ""100\n"".to_i #=> 100
p ""100a"".to_i  #=> 0
p ""a100"".to_i  #=> 0
```","```ruby
p ""100\n"".to_i #=> 0
p ""100a"".to_i  #=> 0
p ""a100"".to_i  #=> 0
```",,,,,,,
Ruby,to_iの引数,"Rubyで`to_i`は、整数値(Integer)に変換するメソッドです。
引数なしで使われることが多いですが、引数をとることもできます。
下記のコードを実行すると、どうなるでしょう。

```ruby
p ""10"".to_i(2)
p ""20"".to_i(16)
```","```ruby
p ""10"".to_i(2)  #=> 2
p ""20"".to_i(16) #=> 32
```","`""10"".to_i(2)`は`10`を`2`進数表記として解釈して数値変換し、2(=2*1+1*0)となります。
`""20"".to_i(16)`は`20`を`16`進数表記として解釈して数値変換し、32(=16*32+1*0)となります。",2,"```ruby
p ""10"".to_i(2)  #=> 5
p ""20"".to_i(16) #=> 1
```","```ruby
p ""10"".to_i(2)  #=> 20
p ""20"".to_i(16) #=> 320
```","```ruby
p ""10"".to_i(2)  #=> 4
p ""20"".to_i(16) #=> 512
```",,,,,,,
Ruby,Hash#to_a,"```ruby
h = { name: ""John"", age: 16 }
p h.to_a
```

このコードを実行すると、どうなりますか。","`[[:name, ""John""], [:age, 16]]`が出力","`to_a`のaはArray(配列)のaです。
HashをArrayに変換したものを返します。",1,"`[:name, ""John"", :age, 16]`が出力",`Enumerator`クラスのインスタンスが出力,エラーになる。,,,,,,,
Ruby,String#chars,"```ruby
p ""abc"".chars
```
このコードを実行すると、どうなりますか。","`[""a"", ""b"", ""c""]`が出力","`chars`メソッドは、文字列を1文字の配列にするメソッドです。
なお、`chars`にブロックを渡したとき、`each_char`と同じ挙動となり、1文字ずつ回します。",0,"""abc""が出力","`[97, 98, 99]`が返る。",エラーになる。,,,,,,,
Ruby,Integer#chr,"```ruby
p 97.chr
```
このコードを実行すると、どうなりますか。","`""a""`が出力","`Integer#chr`は、整数値を文字コードで変換した文字を返します。
""a""の文字コードが97なので、`97.chr`は`""a""`を返します。

",1,"`""97""`が出力",NoMethodErrorとなる,RangeErrorとなる,,,,,,,
Ruby,Hash#keys,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.keys
```
このコードを実行すると、どうなりますか。","`[:A, :B, :AB, :O]`が出力される。","`Hash#keys`は、ハッシュのキーだけにした配列を返します。
なお、キーを1つずつ回したいときは`Hash#each_key`を使います。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.keys #=> [:A, :B, :AB, :O]
```",0,"`[40, 20, 10, 30]`が出力される。",何も出力されない。,NoMethodErrorとなる,,,,,,,
Ruby,Hash#values,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.values
```
このコードを実行すると、どうなりますか。","`[40, 20, 10, 30]`が出力される。","`Hash#keys`は、ハッシュの値だけにした配列を返します。
なお、値を1つずつ回したいときは`Hash#each_value`を使います。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.values #=> [40, 20, 10, 30]
```",1,"`[:A, :B, :AB, :O]`が出力される。",何も出力されない。,NoMethodErrorとなる,,,,,,,
Ruby,Hash#length,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.length
```
このコードを実行すると、どうなりますか。",エラーとなる。,"`Hash#length`は、ハッシュの要素数を返します。
`length`と`size`はエイリアスで、同じ機能を有しています。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.length #=> 4
```",3,4が出力される。,5が出力される。,8が出力される。,,,,,,,
Ruby,Hash#each,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
h.each{ |x| p x }
```
このコードを実行すると、何が表示されますか。","[:A, 40]
[:B, 20]
[:AB, 10]
[:O, 30]","ブロックパラメータ x に渡されるのは、key と value がセットになった配列です。
それぞれを分けた変数で使いたい場合は、次のようにします。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
h.each{ |k, v| p [k, v] }
```",2,"A
B
AB
O","40
20
10
30
",ArgumentError,,,,,,,
Ruby,max_by,"```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.max_by{ |k, v| v }
```
このコードを実行すると、どうなりますか。","`[:A, 40]`が出力される。","`max_by`は、`Enumerable`モジュールから継承されたメソッドです。
ブロックの最終値が最大となるような、キーと値の配列を返します。

```ruby
h = { A: 40, B: 20, AB: 10, O: 30  }
p h.max_by{ |k, v| v } #=> [:A, 40]
```",2,`{ :A => 40 }`が出力される。,`{ :O => 30 }`が出力される。,"`[:O, 30]`が出力される。",,,,,,,
Ruby,Hash.new,"```ruby
h = Hash.new(0)
p h[:a]
```
このコードを実行すると、どうなりますか。",`0`を返す。,"`Hash.new`で空ハッシュ`{}`が作られます。
引数をとると、作られる空ハッシュのデフォルト値に引数が設定されます。

```ruby
h = Hash.new(0)
p h[:a] #=> 0
```
本問ではデフォルト値に`0`が設定されたハッシュが作られ、
添字`:a`はキーとして持たないので、デフォルト値の`0`が返されます。",1,`nil`を返す。,`:a`を出力。,エラーとなる。,,,,,,,
Ruby,Hash.new,"```ruby
h = { h: 1, e: 1, l: 2, o: 1 }
h[:a] #=> nil
h.default = 0
h[:a] #=> 0
p h
```
このコードを実行すると、どうなりますか。","{:h=>1, :e=>1, :l=>2, :o=>1}","```ruby
h = Hash.new(0)
h.default = 0
```
本問ではあとからデフォルト値に`0`を設定しています。
存在しないキーにアクセスしたときに、このデフォルト値が返されます。
キーを新しく設定するわけではないので、本問では元のハッシュが表示されます。",3,"{:h=>1, :e=>1, :l=>2, :o=>1, :default=>0}","{:h=>1, :e=>1, :l=>2, :o=>1, ""default""=>0}","{:h=>1, :e=>1, :l=>2, :o=>1, :a=>0}",,,,,,,
Ruby,uniq,"```ruby
a = [""A"", ""B"", ""O"", ""AB"", ""A"", ""B"", ""O"", ""AB"", ""B"", ""AB""]
p a.uniq
```

このコードを実行すると、どうなりますか。
","`[""A"", ""B"", ""O"", ""AB""]`が出力。","```ruby
a = [""A"", ""B"", ""O"", ""AB"", ""A"", ""B"", ""O"", ""AB"", ""B"", ""AB""]
p a.uniq #=> [""A"", ""B"", ""O"", ""AB""]
```
`uniq`は要素の重複が削除された新しい配列を返します。",0,`false`を返す。,`nil`を返す。,エラーとなる。,,,,,,,
Ruby,uniq!,"```ruby
a = [""A"", ""B"", ""O"", ""AB""]
p a.uniq!
```

このコードを実行すると、どうなりますか。",`nil`を返す。,"```ruby
a = [""A"", ""B"", ""O"", ""AB""]
p a.uniq! #=> nil
```

`uniq!`は、`uniq`と異なる点が2つほどあります。
- `uniq!`は、破壊的メソッドで、レシーバ自体の重複を削除する。
- `uniq!`は、元の配列が変更されないとき(要素の重複がないとき)、`nil`を返す。",2,"`[""A"", ""B"", ""O"", ""AB""]`が出力。",`false`を返す。,エラーとなる。,,,,,,,
Ruby,uniq!,"```ruby
p 5.even?
```

このコードを実行すると、どうなりますか。",`false`を出力する。,"```ruby
p 5.even? #=> false
p 5.odd?   #=> true
```

`even?`は、偶数かどうか判定し、偶数なら`true`, 偶数でないなら`false`を返すメソッドです。
反対に、奇数かどうか判定するメソッドとして、`odd?`メソッドがあります。",1,`true`を出力する。,`nil`を出力する。,エラーとなる。,,,,,,,
Ruby,Array#empty?,"```ruby
p [3, 2, 1].empty?
```

このコードを実行すると、どうなりますか。",`false`を出力する。,"```ruby
p [3, 1, 2].empty? #=> false
p [].empty?           #=> true
```

`empty?`は、空の配列なら`true`を返し、要素があれば`false`を返します。",1,`true`を出力する。,`nil`を出力する。,エラーとなる。,,,,,,,
Ruby,Array#slice,"```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  # ?
p a[1...4] # ?
```

このコードを実行すると、どうなりますか。","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T""]
```

`[1, 4]`は、1番目から4つ取るという意味です。
`1...4`は、点が3つあり、Rubyでは終端を含みません。1番目から3番目をとります。
配列は0から数える点に注意してください。",2,"```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""M"", ""T"", ""W"", ""T""]
p a[1...4] #=> [""M"", ""T"", ""W"", ""T""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""M"", ""T"", ""W"", ""T""]
p a[1...4] #=> [""M"", ""T"", ""W""]
```","```ruby
a = [""M"", ""T"", ""W"", ""T"", ""F"", ""S"", ""S""]
p a[1, 4]  #=> [""T"", ""W"", ""T"", ""F""]
p a[1...4] #=> [""T"", ""W"", ""T"", ""F""]
```",,,,,,,
Ruby,数値の桁和,"2の15乗の各桁の和を正しく求められているものはどれでしょうか。
",`(2**15).digits.sum`,"`Integer`クラスに、`sum`や`digit_sum`というメソッドはありません。
`digits`メソッドを使うと、各桁の配列を返します。
一の位が1番左に来ることに注意してください。

```ruby
p 123.digits    #=> [3, 2, 1]
p [1, 2, 3].sum #=> 6
```
",1,`(2**15).sum`,`(2**15).digit_sum`,`(2**15).sum{ |d| d }`,,,,,,,
Ruby,数値の桁数,2の15乗の桁数を正しく求められているものはどれでしょうか。,`(2**15).to_s.size`,"`Integer`クラスに、`sum`というメソッドはありません。
`Integer`クラスに、`size`というメソッドはありますが、桁数を返すメソッドではなく、実装上のバイト数を返すメソッドです。
`Integer`の桁数を求めるには、一度`to_s`で文字列にしてから、`size`(or `length`)メソッドで文字列の長さを数えるとよいです。

```ruby
p 987.to_s     #=> ""987""
p ""987"".size #=> 3
```

ただし、負数を文字列にしてそのまま数えると、マイナス記号`-`も数えてしまうので注意してください。",3,`(2**15).sum`,`(2**15).size`,`(2**15).to_s.sum`,,,,,,,
Ruby,swap,"```ruby
a = 3
b = 4
```
Rubyで変数`a`と`b`に代入されているものを交換できる方法を選びなさい。","```ruby
a, b = b, a
```","Rubyでは、`a, b = b, a`とすると、変数どうして中身を交換できます。

```ruby
a = 1
b = 2
a, b = b, a
p [a, b] #=> [2, 1]
```

`[a, b] = [b, a]`は、JavaScriptなどの方法。
",0,"```ruby
swap(a, b)
```","```ruby
[a, b] = [b, a]
```","```ruby
(a, b) = (b, a)
```",,,,,,,
Ruby,文字列を整数値の配列へ,"`""2 12 30""` → `[2, 12, 30]`

このように、スペース区切りの文字列を整数値の配列に変換でき**ない**方法をはどれか。","```ruby
""2 12 30"".split(&:to_i)
```","引数なしの`split`メソッドは、スペースや改行で分割して配列を作ります。

```ruby
""2 12 30"".split #=> [""2"", ""12"", ""30""]
```

配列の全ての要素を文字列から数値に変換する方法として、 `map`で新しく配列を作り直すことがよくあります。
```ruby
[""2"", ""12"", ""30""].map{ |e| e.to_i } #=> [2, 12, 30]
[""2"", ""12"", ""30""].map(&:to_i)       #=> [2, 12, 30]
[""2"", ""12"", ""30""].map &:to_i        #=> [2, 12, 30]
```

Rubyは、一定の条件を満たすと、ブロックを省略した記法で書けます。
また、Rubyのメソッドの引数の丸括弧も、省略できるケースが多いです。",2,"```ruby
""2 12 30"".split.map(&:to_i)
```","```ruby
""2 12 30"".split.map &:to_i
```","```ruby
""2 12 30"".split.map{ |e| e.to_i }
```",,,,,,,
Ruby,String#sum,"```ruby
p ""123"".sum
```
このコードを実行すると、どうなりますか。
【ヒント】`""1"".ord`の返り値は、""49""です。",`150`が出力される。,"`""1"".ord`とすると、文字としての1の文字コードの数値49が返されます。
String#sumは、文字列の各文字の文字コードの数値の合計を求めて返すメソッドです。

`""1""`の文字コードが`49`で、`""2""`, `""3""`の文字コードがそれぞれ`50`, `51`です。
したがって、これらの合計の`150`を`""123"".sum`は返します。",3,`3`が出力される。,`6`が出力される。,`123`が出力される。,,,,,,,
Ruby,chompとchop,"```ruby
p ""foo\n"".chomp
p ""foo"".chomp
p ""foo\n"".chop
p ""foo"".chop
```

これの出力で正しい組み合わせを選びなさい。","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""foo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""fo""
```","文字列`String`には、`chomp`と`chop`と名前が似ている上に、
機能が似ていて紛らわしいインスタンスメソッドがあります。

`chomp`は、末尾が改行のときのみ、改行を落とした新しい文字列を返します。
`chop`は、末尾が何か関係なく、末尾の1文字を落とした新しい文字列を返します。

よく使われるのは、`chomp`かなと思います。
1行の最後に改行があったときにだけ改行を削除してくれて、便利です。",2,"```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""fo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""fo""
```
","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""foo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""foo""
```","```ruby
p ""foo\n"".chomp #=> ""foo""
p ""foo"".chomp   #=> ""fo""
p ""foo\n"".chop  #=> ""foo""
p ""foo"".chop    #=> ""foo""
```",,,,,,,
Ruby,String#chomp,"```ruby
p ""0"".chomp
p ""1\n"".chomp
p ""2\n\n"".chomp
p ""3\n\n\n"".chomp
```
正しい出力を選びなさい","""0""
""1""
""2\n""
""3\n\n""","chomp は、末尾に改行があれば、1つ改行を切り落とします。
なお、chomp は、「大きな口で、齧り付いて噛みちぎる」イメージの英単語です。

```ruby
p ""0"".rstrip
p ""1\n"".rstrip
p ""2\n\n"".rstrip
p ""3\n\n\n"".rstrip
```

末尾の空白文字を全て削除したものを得たい場合は、strip や rstrip を用います。 
rstrip の最初の r は right の意味で、右つまり末尾の空白文字のみを削除します。
strip の場合、先頭と末尾の両端の空白文字を削除します。",3,"""""
""1""
""2""
""3""","""0""
""1""
""2""
""3""","""""
""1""
""2\n""
""3\n\n""",,,,,,,
Ruby,String#squeeze,"`""foo     bar          baz""` => `""foo bar baz""`
上記のように連続する半角スペースを1文字にできる方法はどれでしょうか。

圧縮したい文字列は、以下のように変数`str`に入っているものとします。
```ruby
str = ""foo     bar          baz""
```","`str.squeeze("" "")`","各選択肢は、以下のような結果となります。
```ruby
str = ""foo     bar          baz""
p str.delete("" "")    #=> ""foobarbaz""
p str.sub(/ +/, "" "") #=> ""foo bar          baz""
p str.squeeze          #=> ""fo bar baz""
p str.squeeze("" "")   #=> ""foo bar baz""
```

`delete("" "")`は、引数の半角スペースを全て削除してしまいます。
`sub(/ +/, "" "")`は、正規表現で連続した半角スペースを指定して置換しますが、置換する対象は1つのみです。`gsub`メソッドであれば、全ての連続する半角スペースにマッチして、置換します。
`str.squeeze`は、引数がないため半角スペースに限らず、全ての連続する文字を1文字に圧縮しています。
`str.squeeze("" "")`は、本問の正解で、引数で半角スペースのみを指定して、半角スペースのみを圧縮しています。

なお、squeezeという英単語は、「(スポンジやレモン等を)握りつぶして絞る」イメージです。",3,`str.delete(' ')`,"`str.sub(/ +/, "" "")`",`str.squeeze`,,,,,,,
Ruby,Hash#invert,"```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert
p colors
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
p colors        #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
```","知ってるか、知らないかの知識問題でしょう。

`Hash#invert`は、ハッシュのキーと値を反転させるメソッドです。
新しい反転させたハッシュを作りますが、
破壊的メソッドではないのでレシーバは元のまま変わりません。

「invert」という英単語は、「逆にする、反対にする」といった意味です。

",1,"```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
p colors        #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
p colors        #=> {""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}
```","```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.invert #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
p colors        #=> {:white=>""#fff"", :red=>""#f00"", :blue=>""#00f""}
```",,,,,,,
Ruby,Array#to_s,"`[1, 2, 3]` => `""1 2 3""`
上記のように、整数値の配列を、スペース区切りにした文字列にしたいです。","```ruby
[1, 2, 3].join("" "")
```","文字列を配列にするときは`split`がよく用いられ
配列を文字列にするときは`join`がよく用いられます。

```ruby
p [1, 2, 3].to_s         #=> ""[1, 2, 3]""
p [1, 2, 3].join         #=> ""123""
p [1, 2, 3].join("" "")  #=> ""1 2 3""
p [1, 2, 3].join("", "") #=> ""1, 2, 3""
```

なお、選択肢の`[1, 2, 3].to_s("" "")`を実行すると、`Array#to_s`に引数を指定する方法はないので`ArgumentError`となります。",3,"```ruby
[1, 2, 3].to_s
```","```ruby
[1, 2, 3].to_s("" "")
```","```ruby
[1, 2, 3].join
```",,,,,,,
Ruby,全角の数字,"`""１２３"".to_i`
このような全角の数字の文字列に`to_i`メソッドを使うとどうなるでしょうか。",0が返される。,"`String#to_i`は、先頭の文字が、半角の数字以外だと0を返します。

```ruby
p ""abc"".to_i   #=> 0
p ""１２３"".to_i #=> 0
```

数字のように見えても全角の数字は、Rubyだと数字の扱いを受けないので注意しましょう。
",0,123が返される。,nilが返される。,エラーとなる。,,,,,,,
Ruby,全角スペースのsplit,"```ruby
p ""1 2 3"".split  # ?
p ""4　5　6"".split # ?
```

上の文字列は半角スペースで区切られていますが、
下の文字列は全角スペースで区切られています。
このコードを実行すると、どうなりますか。","```ruby
p ""1 2 3"".split   #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split #=> [""4　5　6""]
```
",`String#split`は、引数を指定しないと半角スペースや改行で分割して配列を作りますが、全角スペースでは分割しないようです。,2,"```ruby
p ""1 2 3"".split  #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split #=> [""4"", ""5"", ""6""]
```
","```ruby
p ""1 2 3"".split   #=> [1, 2, 3]
p ""4　5　6"".split #=> [4, 5, 6]
```
","```ruby
p ""1 2 3"".split   #=> [""1"", ""2"", ""3""]
p ""4　5　6"".split # エラーになる。
```",,,,,,,
Ruby,引数なしのsplit,"String#splitは、引数に区切りの文字などを指定します。
```ruby
p ""1,2,3\n"".split("" "") #=> [1, 2, 3]
```
さて、引数を指定してない次のコードの場合、どうなりますか。
```ruby
p "" 1 2 3\n4 5 6\n"".split # ?
```","[""1"", ""2"", ""3"", ""4"", ""5"", ""6""] を表示する","
引数なしの場合や第1引数に半角スペースをとった場合、
空白文字(半角スペースや改行)で分割される上、
先頭と末尾の空白文字も取り除かれます。
```ruby
s = "" 1 2 3\n4 5 6\n""
p s.split      #=> [""1"", ""2"", ""3"", ""4"", ""5"", ""6""]
p s.split("" "") #=> [""1"", ""2"", ""3"", ""4"", ""5"", ""6""]
p s.split(""\n"") #=> ["" 1 2 3"", ""4 5 6""]
```",1,"["" 1 2 3"", ""4 5 6""]","[""1"", ""2"", ""3\n"", ""4"", ""5"", ""6""]","["" 1"", ""2"", ""3\n"", ""4"", ""5"", ""6\n""]",,,,,,,
Ruby,Hash#map,"```ruby
colors = {white: ""#fff"", red: ""#f00"", blue: ""#00f""}
p colors.map{ |k, v| [v, k] }
```

このコードを実行すると、どうなりますか。","`[[""#fff"", :white], [""#f00"", :red], [""#00f"", :blue]]`を出力する。",`Array#map`でも、`Hash#map`でも、配列(Array)を作って返すメソッドです。,0,"`{""#fff""=>:white, ""#f00""=>:red, ""#00f""=>:blue}`を出力する。",ブロックの最終値はハッシュを作る必要があるが、配列を作っているので、TypeErrorという例外をだす。,Hashにmapメソッドはないので、NoMethodErrorという例外をだす。,,,,,,,
Ruby,String#end_with?,"```ruby
p ""icon1.png"".end_with?("".png"")
p ""icon2.gif"".end_with?("".png"")
```

このコードを実行すると、どうなりますか。","```ruby
p ""icon1.png"".end_with?("".png"") #=> true
p ""icon2.gif"".end_with?("".png"") #=> false
```","知らなくても、メソッド名からある程度の想像はできるのかな、と思います。
`String#end_with?`は、文字列があるパターンで終わっているかどうかを調べます。
反対に先頭を調べるメソッドとして、`start_with?`メソッドも存在します。",1,"```ruby
p ""icon1.png"".end_with?("".png"") #=> true
p ""icon2.gif"".end_with?("".png"") #=> true
```","```ruby
p ""icon1.png"".end_with?("".png"") #=> false
p ""icon2.gif"".end_with?("".png"") #=> true
```","```ruby
p ""icon1.png"".end_with?("".png"") #=> false
p ""icon2.gif"".end_with?("".png"") #=> false
```",,,,,,,
Ruby,prime?,"```ruby
require ""prime""
p 2.prime? # ?
p 3.prime? # ?
p 4.prime? # ?
```

このコードを実行すると、どうなりますか。","```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> true
p 4.prime? #=> false
```","`require ""prime""`で、`prime`ライブラリがロードされ、
`Integer#prime?`が拡張されるなど、素数周りの機能が使えるようになります。

`Integer#prime?`は、素数かどうか判定して、真偽値を返すメソッドです。

【補足】
素数は、1より大きい自然数の中で、正の約数が1と自分自身のみの数です。
2や3は1と自分自身のみを正の約数として持つので、素数です。
4は、1と自分自身の他に2を正の約数として持つので、素数ではありません。",1,"```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> true
p 4.prime? #=> true
```","```ruby
require ""prime""
p 2.prime? #=> true
p 3.prime? #=> false
p 4.prime? #=> false
```","```ruby
require ""prime""
p 2.prime? #=> false
p 3.prime? #=> false
p 4.prime? #=> false
```",,,,,,,
Ruby,clear,次の選択肢の中で、エラーとなるものはどれでしょうか。,"```ruby
i = 1
i.clear
p i #=> 0
```","Array, Hash, Stringには、破壊的に空にする`clear`メソッドがあります。
しかし、Integerに、そのようなメソッドはありませんし、破壊的メソッドがありません。",3,"```ruby 
a = [1, 2, 3]
a.clear
p a #=> []
```","```ruby 
h = {white: ""fff"", black: ""000""}
h.clear
p h #=> {}
```","```ruby 
s = ""string""
s.clear
p s #=> """"
```",,,,,,,
Ruby,エイリアスの多いメソッド,`Hash#key?`のエイリアスで**ない**メソッドは、どれでしょう。,`have_key?`,"Rubyコアの中で、エイリアスが多いメソッドです。最多でしょうか?
Rubyコアでメソッド名の中の動詞は原形で使われていることが多いですが、`has_key?`や`has_value`は珍しく三単現(三人称・単数形・現在形)です。

【注意】
`Hash#key?`というメソッドの他に、`Hash#key`という別のメソッドもあるので注意してください。

【補足：原形のメソッド】
原形のメソッドとして,`Array#include?`や`String#start_with?`などがあります。
Rubyの生みの親のMatzさん自身は、原形で統一したいと考えているようです。
なお、`puts`は、「put」と「string」が由来で、三単現ではありません。",3,`include?`,`member?`,`has_key?`,,,,,,,
Ruby,文字列が要素の配列,"`[""月"", ""火"", ""水"", ""木"", ""金"", ""土"", ""日""]`という配列を作れる%記法は、次のうちどれ。",`%w[月 火 水 木 金 土 日]`,"```ruby
p %i[月 火 水 木 金 土 日] #=> [:月, :火, :水, :木, :金, :土, :日]
p %w[月 火 水 木 金 土 日] #=> [""月"", ""火"", ""水"", ""木"", ""金"", ""土"", ""日""]
```

%wの記法による文字列が要素の配列の生成は、`,`や`""`を書かなくて済むので、見た目が少しスッキリします。",3,`%i[月 火 水 木 金 土 日]`,`%q[月 火 水 木 金 土 日]`,`%s[月 火 水 木 金 土 日]`,,,,,,,
Ruby,Range#to_a,"`(0...5).to_a`は、`[0, 1, 2, 3, 4]`の連番の配列を作ります。
これと異なる配列を作るものは、次のうちどれでしょう。",`[0..4]`,"`[0..4]`は、`0..4`という`Range`クラスのインスタンスが1要素としてある配列です。
",2,`[*0...5]`,`[*(0..4)]`,`5.times.to_a`,,,,,,,
Ruby,each_cons,"```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a
p a.each_cons(3).to_a
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]
```","`each_slice(3)`とすると、要素数3の幅で区切っていきます。
`each_cons(3)`とすると、要素数3の幅で1つずつスライドしていきます。",3,"```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, nil, nil]]
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]
```","```ruby
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
p a.each_slice(3).to_a #=>  [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]
p a.each_cons(3).to_a  #=> [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]
```",,,,,,,
Ruby,each,"```ruby
(0...5).each do |i|
  p i
end
```
0から4まで順番に出力します。
これと異なる出力をするものは、どれでしょうか。","```ruby
""01234"".each_char do |i|
  p i
end
```","`each_char`(or `chars`)は、文字列をの文字を1文字ずつ回すメソッドであり、
これを使う選択肢のみ文字で回しており、他は整数値で回しています。",3,"```ruby
(0...5).each do |i|
  p i
end
```","```ruby
0.upto(4) do |i|
  p i
end
```","```ruby
[0, 1, 2, 3, 4].each do |i|
  p i
end
```",,,,,,,
Ruby,object_id,"```ruby
a = [1, 2, 3]
b = a

a << 4
b.push(5)

p a # ?
p b # ?
```","```ruby
p a #=> [1, 2, 3, 4, 5]
p b #=> [1, 2, 3, 4, 5]
```","`b = a`で同じオブジェクトIDが代入され、変数`a`も`b`も同じ配列を参照することになります。
また、`<<`も`push`も要素を追加する破壊的メソッドです。
どちらの追加でも、全く同じ配列に対して破壊的に要素を追加しており、`a`から見ても`b`から見ても同じ結果を返します。",3,"```ruby
p a #=> [1, 2, 3]
p b #=> [1, 2, 3]
```","```ruby
p a #=> [1, 2, 3, 4]
p b #=> [1, 2, 3, 5]
```","```ruby
p a #=> [1, 2, 3, 4]
p b #=> [1, 2, 3, 4]
```",,,,,,,
Ruby,Array#*,"```ruby
p [0] * 5
p [1] * 5
p [] * 5
```","```ruby
p [0] * 5 #=> [0, 0, 0, 0, 0]
p [1] * 5 #=> [1, 1, 1, 1, 1]
p [] * 5  #=> []
```","文字列に対して整数値(Integer)を乗じたときと同じような挙動ですね。

```ruby
""a"" * 3 #=> ""aaa""
"""" * 3  #=> """"
```",2,"```ruby
p [0] * 5 #=> [0]
p [1] * 5 #=> [5]
p [] * 5  #=> []
```
","```ruby
p [0] * 5 #=> [0]
p [1] * 5 #=> [5]
p [] * 5  #=> [nil]
```","```ruby
p [0] * 5 #=> [0, 0, 0, 0, 0]
p [1] * 5 #=> [1, 1, 1, 1, 1]
p [] * 5  #=> [nil, nil, nil, nil, nil]
```",,,,,,,
Ruby,do~endと{~}の違い,"```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #  ?
p a.map do |e| e * 3 end # ?
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> [9, 3, 6]
p a.map do |e| e * 3 end #=> #<Enumerator: [3, 1, 2]:map>
```","Rubyのあらゆるメソッドは、ブロックを使う機能がなかったとしても、ブロックを取ることができます。
```ruby
p(""Hello, World""){ ""unused block"" }
5.+(4){ ""unused block"" }
```

そして、2つのメソッドが連続していて丸括弧を書かなかったときに、`do ~ end`と`{ ~ }`で、ブロックがどちらのメソッドに紐づくかパースの仕方が変わってきます。

```ruby
p(a.map { |e| e * 3 })
p(a.map)do |e| e * 3 end
```

`{ ~ }`のブロックは内側のメソッドと紐づきますが、`do ~ end`のブロックだと外側のメソッドと紐づきます。

",1,"```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> [9, 3, 6]
p a.map do |e| e * 3 end #=> [9, 3, 6]
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> #<Enumerator: [3, 1, 2]:map>
p a.map do |e| e * 3 end #=> [9, 3, 6]
```","```ruby
a = [3, 1, 2]

p a.map { |e| e * 3 }    #=> #<Enumerator: [3, 1, 2]:map>
p a.map do |e| e * 3 end #=> #<Enumerator: [3, 1, 2]:map>
```",,,,,,,
Ruby,配列の範囲外のセット,"```ruby
a = []
a[2] = ""x""
p a
```","`[nil, nil, ""x""]`が出力される。","配列の要素数を超えた位置(正の数)に要素をセットしようとすると、配列が拡張され、拡張される部分は`nil`で埋められます。

4番目の選択肢は、負の数で範囲を超えたときに起こるエラーを真似したものです。",1,"`[""x"", ""x"", ""x""]`が出力される。
","`[""x""]`が出力される。",`index 2 too large for array; minimum: nil (IndexError)`というエラーが起きる。,,,,,,,
Ruby,配列の負の範囲外のセット,"```ruby
a = []
a[-1]
a[-2] = ""x""
p a
```","2行目の`a[-1]`は問題ないが、3行目の`a[-2] = ""x""`でIndexErrorとなる。","オブジェクトを取るとき(ゲット)、配列の範囲外を参照しても`nil`を返します。
対して、オブジェクトをセットするとき、負の値だとエラーとなります。",3,`[]`が出力される。,"`[""x""]`が出力される。",2行目の`a[-1]`で、IndexErrorとなる。,,,,,,,
Ruby,デフォルトProc,"`Array`, `String`, `Hash`の親クラスは`Object`ですが、同様に`Object`の親クラスを調べるとどうなりますか。

```ruby
p Array.superclass  #=> Object
p String.superclass #=> Object
p Hash.superclass   #=> Object
p Object.superclass # ?
```",`Object`の親クラスの`BasicObject`が返る。,"多くのクラスの親ないし祖先は`Object`であり、`Object`が基本の土台となるクラスです。
新しくクラスを定義する際に、デフォルトで`Object`を継承します。
しかし、`Object`の直接の親に機能が最低限の`BasicObject`クラスが存在します。",3,`Object`の親クラスは存在しないので、`nil`が返る。,`Object`の親クラスは存在しないので、エラーとなる。,`Object`の親クラスの`Object`自分自身であり、`Object`が返る。,,,,,,,
Ruby,Arrayのnil,"`[0, """", nil, false, []]` → `[0, """", false, []]`
配列の要素から`nil`を取り除いた配列を返すメソッドは何でしょうか。",compact,"compactが、配列の要素からnilを削除するメソッドです。

squeezeは、Stringの連続した部分を1文字に潰すメソッド。
stripは、Stringの左右の無駄なスペースを削除するメソッド。
uniqは、Arrayの重複している要素を削除するメソッド。",3,squeeze,strip,uniq,,,,,,,
Ruby,シフト演算子,"`Integer`クラスの`<`は比較演算子と呼ばれるメソッドですが、
`<<`はシフト演算子と呼ばれるメソッドです。
記号の数も違い(=名前が違い)、機能が全くの別物です。

以下のコードの実行結果はどうなるでしょうか。
```ruby
i = 1
p i << 1
p i << 2
p i << 3
p i
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 4
p i << 3 #=> 8
p i      #=> 1
```","Rubyで、Integerのような数値のクラスのインスタンスは、イミュータブルで変更不可能で、破壊的メソッドはなく、基本的に`=`や`+=`のような代入などによって別のオブジェクトに書き換えられない限り、変わることはありません。

今回のケースでは、Integerに`<<`を使っても破壊的メソッドではないので、変数`i`は書き換わらず、常に変数に`1`が代入されたままです。
`<<`はシフト演算子で、`i << n`は`i`を`n`乗した値を返します。",1,"```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 8
p i << 3 #=> 64
p i      #=> 64
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 4
p i << 3 #=> 7
p i      #=> 7
```","```ruby
i = 1
p i << 1 #=> 2
p i << 2 #=> 3
p i << 3 #=> 4
p i      #=> 1
```",,,,,,,
Ruby,シフト演算子,"以下のコードを実行したときの最後の出力の結果はどうなりますか。
```ruby
i = 1
a = []

i << 1
a << 1
a.push(2)

p i
p a
```","```ruby
p i  #=> 1
p a  #=> [1, 2]
```","`Integer`クラスの`<<`はシフト演算子と呼ばれるメソッドで、`i << n`は`i`の`n`乗を返します。しかし、`Integer`クラスは変更不可能(イミュータブル)なクラスであり、破壊的メソッドはなく、メソッドのレシーバに影響を及ぼすことはありません。

対して、`Array`クラスの`<<`は、末尾に要素を追加する破壊的メソッドです。`push`も`<<`と同様の機能で、末尾に要素を追加する破壊的メソッドです。

結果的に、本問では、`Integer`クラスの変更はないですが、`Array`クラスは変更なされます。",2,"```ruby
p i  #=> 1
p a  #=> []
```","```ruby
p i  #=> 2
p a  #=> []
```","```rubh
p i  #=> 2
p a  #=> [1, 2]
```",,,,,,,
Ruby,object_id,"以下のコードを実行したときの最後の出力の結果はどうなりますか。
```ruby
n1 = 1
n2 = 1

a1 = []
a2 = []

p n1.object_id == n2.object_id
p a1.object_id == a2.object_id
```","```ruby
p n1.object_id == n2.object_id #=> true
p a1.object_id == a2.object_id #=> true
```","ミュータブルなオブジェクトには破壊的メソッドがあり、破壊的メソッドを使うとレシーバ自身のオブジェクトの中身を破壊的に変更する可能性があります。
イミュータブルなオブジェクトに破壊的メソッドがなく、オブジェクトの中身が変わることがありません。イミュータブルなオブジェクトは、中身が同じであれば、オブジェクトIDも等しくなります。

【変更可能(ミュータブル)】配列、ハッシュ、文字列など
【変更不可能(イミュータブル)】`true`, `false`, `nil`, 数値, シンボル",0,"```ruby
p n1.object_id == n2.object_id #=> true
p a1.object_id == a2.object_id #=> false
```","```ruby
p n1.object_id == n2.object_id #=> false
p a1.object_id == a2.object_id #=> true
```","```ruby
p n1.object_id == n2.object_id #=> false
p a1.object_id == a2.object_id #=> false
```",,,,,,,
Ruby,定数,Rubyの定数について、誤っているものを選びなさい。,定数は、メソッド内で動的に代入することができます。,"他のプログラミング言語では定数が再代入や変更できないものを意味することもありますが、
 Rubyの定数は、警告(warning)こそあるものの、再代入できてしまいます。

```ruby
CONST = 1
CONST = 2
# Main.rb:2: warning: already initialized constant CONST
# Main.rb:1: warning: previous definition of CONST was here
```

ただし、メソッド内で動的に定数を定義するようなことはできません。

```ruby
def foo
  CONST = 2
end
# Main.rb:5: dynamic constant assignment
#  CONST = 2
#   ^~~~~
```",3,定数名は大文字始まりです。,定数は、再代入できます。,定数に、再代入すると警告がでます。,,,,,,,
Ruby,定数,"下記のコードを実行すると、何が出力されますか。

```ruby
class Foo
end
Bar = Foo

p Foo.new.class
p Bar.new.class
```","```ruby
p Foo.new.class #=> Foo
p Bar.new.class #=> Foo
```","```ruby
class Foo
end
```

上記のように書くと、`Foo`クラスが定義され、定数`Foo`は`Class`クラスのインスタンスとなります。`Bar = Foo`とすることで、定数`Bar`にも全く同じインスタンスが代入され、結果的に`Bar`は`Foo`のエイリアスとなります。
",1,"```ruby
p Foo.new.class #=> Foo
p Bar.new.class #=> Bar
```","```ruby
p Foo.new.class #=> Bar
p Bar.new.class #=> Bar
```","```ruby
p Foo.new.class #=> Bar
p Bar.new.class #=> Foo
```",,,,,,,
Ruby,freeze,"```ruby
str = ""foo"".freeze
str.upcase!
p str
```",FrozenErrorが発生する。,"`upcase!`は、文字列を大文字にする破壊的メソッドです。
しかし、本問では、`freeze`が使われ、文字列が`frozen`(凍結=変更不可能)な状態になっています。そのため、変更不可能な文字列に破壊的変更を加えようとした結果、FrozenErrorが発生します。",3,"""foo""が表示される。","""Foo""が表示される。","""FOO""が表示される。",,,,,,,
Ruby,freeze,"```ruby
bloods = [""a"", ""b"", ""ab"", ""o""].freeze
bloods.each(&:upcase!)
p bloods
```","`[""A"", ""B"", ""AB"", ""O""]`が表示される。",本問でfreezeされているのは配列であり、中身の文字列までfreezeされているわけではありません。配列に対して`reverse!`や`sort!`のような破壊的メソッドで破壊的に変更することはできませんが、要素としての配列はfreezeされてないので`upcase!`で大文字にすることができます。,1,"`[""a"", ""b"", ""ab"", ""o""]`が表示される。","下記のようなエラーとなる。
```
Main.rb:2:in `upcase!': can't modify frozen String: ""a"" (FrozenError)
```","下記のようなエラーとなる。
```
Main.rb:2:in `<main>': undefined method `upcase!' for String: ""a"" (NoMethodError)`
```",,,,,,,
Ruby,Arrayのエイリアス,Arrayのインスタンスメソッドの中で、エイリアスで**ない**組み合わせを選びなさい。,"sample, suffle","sampleはランダムに要素を選ぶメソッドで、shuffleはランダムに要素を並び替えるメソッドで、別の機能です。
mapとcollectは、比較的昔からあるエイリアスです。
対して、appendとprependは、Ruby 2.5(2017年12月リリース)で、元からあったpushとunshiftに追加される形で出来たエイリアスです。",0,"map, collect","push, append","unshift, prepend",,,,,,,
Ruby,Arrayのエイリアス,Arrayのインスタンスメソッドの中で、説明が誤っているものを選びなさい。,shiftは先頭に要素を追加する破壊的メソッドで、unshiftは先頭から要素を出す破壊的メソッド。,unshiftが配列の先頭に要素を追加するメソッドで、shiftが配列の要素をだすメソッドです。,1,pushは末尾に要素を追加する破壊的メソッドで、popは末尾から要素を出す破壊的メソッド。,appendは、Ruby2.5でpushのエイリアスとして追加された破壊的メソッド。,prependは、Ruby2.5でunshiftのエイリアスとして追加された破壊的メソッド。,,,,,,,
Ruby,Mathモジュール,Mathモジュール内の円周率を表す定数の呼び出し方として正しいものを選びなさい。,`Math::PI`,"モジュール内の定数を呼ぶときは、`::`です。
なお、`Math`モジュールをインクルードすれば、そのまま定数を呼び出せます。

```ruby
include Math
p PI
```

",3,`Math.PI`,`Math:PI`,`Math.:PI`,,,,,,,
Ruby,累乗演算子の優先順位,2 ** 3 ** 2,512,"+や-などの一般的な記号は、左から順番に計算されますが、 **は右から計算されます。
これは、数式で表現したときの計算順序に合わせたものです。",1,64,SyntaxErrorとなる,NoMethodErrorとなる,,,,,,,
Ruby,String,"文字列の先頭に(破壊的に)追加するメソッドは、`prepend`です。

```ruby
str = ""bar""
str.prepend(""foo"")
p str #=> ""foobar""
```

さて、文字列の末尾に追加でき**ない**方法はどれでしょうか。

```ruby
str = ""foo""
```

変数`str`の末尾に`""bar""`を追加して`""foobar""`にします。","`str.append(""bar')`","配列の方には要素の追加に`append`と`prepend`の両方があります。
しかし、文字列の方は`prepend`はあるものの`append`はありません。

`<<`と`concat`は破壊的メソッドですが、`+=`は新しく結合させて作ったものを再代入しているという違いがあるので、注意しましょう。`+=`の方は破壊的に変更しない代わりに、とても遅くなる可能性があります。
",2,"`str += ""bar'`","`str << ""bar'`","str.concat(""bar')",,,,,,,
Ruby,attr_reader,"```ruby
class User
  attr_reader :name
end

p User.new.name
```",`nil`が表示される。,"`attr_reader`は、メソッドを作るメソッドです。
本問では、`atrr_reader :name`で、下記のメソッドを作っています。

```ruby
def name
  @name
end
```

ここで、`User.new.name`とすると、`name`インスタンスメソッドが呼び出され、`@name`インスタンス変数が参照されますが、まだ代入されてない変数です。
未定義のローカル変数の場合はエラーとなりますが、このように代入されてないインスタンス変数は`nil`を返します。",0,NameErrorとなる。,NoMethodErrorとなる。,TypeErrorとなる。,,,,,,,
Ruby,block_given?,"```ruby
def foo
  if block_given?
    p ""With block!""
  else
    p ""Without block!""
  end
end

foo
```","`""Without block!""`が表示される。","`block_given?`は、メソッドにブロックが与えられているかどうか判定するメソッドです。
本問で、`foo`メソッド呼び出しする時にブロックが与えられてないので、`block_given?`は`false`となり、`""Without block!""`が表示されます。
なお、`foo{}`などのように呼び出せば、`block_given?`が`true`になります。

`block_given?`は、定義するメソッドでブロックの有無で動作を変更するような場合に使います。",1,"`""With block!""`が表示される。",ArgumentErrorとなる。,NoMethodErrorとなる。,,,,,,,
Ruby,Class,"`Class`クラスが継承している親クラスはなんでしょうか。
```ruby
p Class.superclass #=> ?
```",`Module`,"`Class`クラスは、`Module`クラスを継承しているクラスです。
なお、クラスとモジュールの違いとして、クラスはインスタンスを作ったり継承できる等の違いがあります。",3,`Object`,`BasicObject`,`Class`,,,,,,,
Ruby,Module,"`Module`クラスが継承している親クラスはなんでしょうか。
```ruby
p Module.superclass #=> ?
```",`Object`,"`Module`は、`Object`クラスを継承しているクラスです。
なお、`Module`を継承しているクラスとして、`Class`クラスがあります。",0,`BasicObject`,`Class`,`Module`,,,,,,,
Ruby,Module,"以下のコードを実行すると、どうなるでしょう。
```ruby
h = { A: 25, B: 25, AB: 25, O: 25 }
p h.invert
```",`{25=>:O}`と表示される。,"Hashのキーは重複することはありません。
`invert`はキーと値を反転させたハッシュを作るメソッドですが、キーとなる値が重複していた場合、最後のキーが値として反転したときに残ります。

実際のところ、値が重複するようなケースで`invert`を使ってしまうと情報が失われてしまうので、使わない方がいいと思われる。",2,"`{25=>:A, 25=>:B, 25=>:AB, 25=>:O}`と表示される。",`{25=>:A}`と表示される。,エラーとなる,,,,,,,
Ruby,比較のメソッド,`object_id`が同じかどうか調べるメソッドはどれですか。,`equal?`,"基本的に使うのは`==`で、知識問題という感じがします。

`x.equal?(y)`は、`x.object_id == y.object_id`と同じと考えられます。
`[].equal?([])`でも`false`を返すので、最も等号が成り立つ条件が厳しいと考えられます。",3,`==`,`===`,`eql?`,,,,,,,
Ruby,===,"`===`はcase文の中で使われてる演算子(メソッド)です。
`==`は使っても、通常`===`は明示的に使いません。

さて、次のコードを実行すると、どうなりますか。
```ruby
p [] === []
p Array === []
p [] === Array
```

【ヒント】`String === ""str""`は`true`を返します。","```ruby
p [] === []      #=> true
p Array === [] #=> true
p [] === Array #=> true
```","case文の中で`===`は使われています。
```ruby
a = []
case a
  when Array
    ""Array""
  else
    ""Not Array""
  end
end
```",0,"```ruby
p [] === []      #=> true
p Array === [] #=> true
p [] === Array #=> false
```","```ruby
p [] === []      #=> true
p Array === [] #=> false
p [] === Array #=> false
```","```ruby
p [] === []      #=> false
p Array === [] #=> false
p [] === Array #=> false
```",,,,,,,
Ruby,三項演算子,"```ruby
cond = true
p cond ? ""Yes"" : ""No""
```","`""Yes""`と表示される",三項演算子です。簡易な条件分岐で用いられます。,0,"`""No""`と表示される",syntax errorとなる,NoMethodErrorとなる,,,,,,,
Ruby,三項演算子,"```ruby
ans = 0 < 1 ? ""Yes"" : ""No""
p ans
```","`""Yes""`と表示される","三項演算子です。簡易な条件分岐で用いられます。
慣れてないと見にくいかもしれませんが、
簡単な",,"`""No""`と表示される",syntax errorとなる,NoMethodErrorとなる,,,,,,,
Ruby,三項演算子,"```ruby
a = [1, 2, 3]
p a.empty ? ""Yes"" : ""No""
```",NoMethodErrorとなる,"配列に`empty?`メソッドはありますが、`empty`メソッドはないので、`NoMethodError`となります。

> Main.rb:2:in `<main>': undefined method `empty' for [1, 2, 3]:Array (NoMethodError)
Did you mean?  empty?

2行目で、Arrayクラスの [1, 2, 3] に empty メソッドは未定義で、
ひょっとしたら、empty? の書き間違いじゃないの？ 
という内容のエラー文が表示されます。

空配列かどうか判定したい場合は、次のようになります。

```ruby
a = [1, 2, 3]
p a.empty? ? ""Yes"" : ""No""
```",3,"`""Yes""`と表示される","`""No""`と表示される。",syntax errorとなる,,,,,,,
Ruby,String#delete,"```ruby
s = ""abcdef""
s.delete(""b-d"")
s.delete!(""c-e"")
p s
```","`""abf""`が表示される","`Array`や`Hash`の`delete`メソッドは破壊的メソッドです。
一方で、`String`には`delete`と`delete!`があり、`delete!`が破壊的メソッドです。
`String#delete!`の引数で`""c-e""`とすると、`c`から`e`までの文字が削除されます。
",0,"`""abdf""`が表示される",syntax errorとなる,NoMethodErrorとなる,,,,,,,
Ruby,Hash#delete,"`Array`の`delete`メソッドは、次の挙動をします。
```ruby
a = [:x, :y, :z, :w]
a.delete(:a)
a.delete(:y)
p a #=> [:x, :z, :w]
```

`Hash`の`delete`メソッドについて、次のコードはどうなりますか。
```ruby
h = {0 => 1, 1 => 2, 10 => 1024}
h.delete(1)
h.delete(10)
p h
```","`{0=>1, 10=>1024}`","Arrayが添字ではなく要素を指定して削除して詰める。
対して、Hashは値を指定削除するのかなと思いきや、キーを指定して削除する。`Hash#delete`は、`Array#delete`より`Array#delete_at`に近いような気もする。

あまり使うメソッドではない気がするが、Ruby技術者認定試験Silverあたりにはでるかもしれないので、追加した。",1,"`{0=>1, 1=>2, 10=>1024}`",`{10=>1024}`,エラーとなる,,,,,,,
Ruby,Array#delete,"```ruby
a = [0, 2, 4, 6, 8, 10, 0, 2, 4]
a.delete_at(4)
a.delete(2)
p a
```","`[0, 4, 6, 10, 0, 4]`","`Array#delete`も`Array#delete_at`も破壊的メソッドです。

 `delete_at(4)`なので、左から4番目の8を削除します。
※0始まりで数えることに注意してください。

次に、`delete(2)`で、要素が`2`のものを全て削除します。",3,"`[0, 4, 6, 10, 0, 2, 4]`","`[0, 4, 8, 10, 0, 4]`","`[0, 2, 6, 10, 0, 2]`",,,,,,,
Ruby,Range#to_a,`p ('a'..'c').to_a`を実行すると、どうなりますか。,"`[""a"", ""b"", ""c""]`を出力する","`(1..3).to_a`が`[1, 2, 3]`となるように、
`('a'..'c').to_a`は`[""a"", ""b"", ""c""]`となります。",0,"`[""a""..""c""]`を出力する。","`[""a"", ""b""]`を出力する。",エラーとなる。,,,,,,,
Ruby,配列の注意点,"```ruby
a = ['xyz'] * 3
a[0].tr!(""x-z"", ""a-c"")
p a
```","`[""abc"", ""xyz"", ""xyz""]`","次の方法で、配列の中身を同じ要素にすると、オブジェクトIDが全く同じ要素となります。
```ruby
a = [""xyz""] * 3
p a[0].object_id == a[1].object_id #=> true
```
オブジェクトIDが同じ要素に対して、破壊的変更を加えると、同じオブジェクトを見てるので、他の要素が変わります。",0,"`[""ayc"", ""xyz"", ""xyz""]`","`[""abc"", ""abc"", ""abc""]`","`[""ayc"", ""ayc"", ""ayc""]`",,,,,,,
Ruby,tr,"```ruby
p ""GTATGC"".tr(""ATCG"", ""TAGC"")
```","`""CATACG""`","`tr`は文字列内の文字をスワップさせるときに便利です。
本問では、`A`と`T`を入れ替え、`G`と`C`を入れ替えています。",1,"`""GTTAGC""`","`""GTATGC""`","`""CATAGC""`",,,,,,,
Ruby,String#reverse,"`""evil"".reverse`は何を返しますか","""live""",`reverse`は文字通り逆転させるメソッドです,2,"""EVIL""","""Evil""","""evil""",,,,,,,
Ruby,?1,`p ?1`,"`""1""`が出力される。","`""a""`や`""1""`のような1文字の文字列は、文字リテラルという表記で`?a`や`?1`と書くことができます。

なお、Ruby 1.8以前では、`?1`で文字コードの数値49を返していました。",1,`1`が出力される。,`49`が出力される。,SyntaxErrorとなる,,,,,,,
Ruby,puts,"以下のコードを実行すると、どうなりますか。
```ruby
class User
  def initialize(first, last)
    @first = first
    @last = last
  end

  def to_s
    ""#{@first} #{@last}""
  end
end

puts User.new(""Abraham"", ""Lincoln"")
```",`Abraham Lincoln`と出力される。,"ほとんどのオブジェクトは、Object#to_sを継承しているか、`to_s`が再定義されており、`to_s`を持ちます。
そして、putsの内部では, 基本的に`to_s`が実行され、その返り値を利用します。
本問では、`to_s`で文字列を返すように再定義されており、その返り値の文字列を出力します。",1,`#<User:0x0000000001f621a0>` と出力される。,NoMethodErrorとなる。,TypeErrorが起きる,,,,,,,
Ruby,ローカル変数,"```ruby
if false
  foo = ""never""
end

p foo
```",`nil`を出力する。,"本問のコードはif文の条件式が`false`で`foo`に代入されることはありません。
しかし、たとえ、実行されなくても、ローカル変数に代入する文があれば、ローカル変数が宣言されたことになり代入前に`nil`を返すようになっています。",0,SyntaxErrorとなる,NameErrorとなる,NoMethodErrorとなる,,,,,,,
Ruby,Date,"```ruby
require ""date""

today = Date.today

puts today.sunday? #=> true
puts today.friday?   # ?
```

上記のコードで`today.sunday?`が`true`を返しましたが、`today.friday?`はどうなりますか?",`false`を返す,"`Date.today`は、今日の日付を返すクラスメソッド(特異メソッド)です。

Dateクラスにはそれぞれの曜日を判定するメソッドが用意されています。
いまコードで日曜日かの判定で`true`を返しているので、金曜日かの判定では`false`を返します。",1,`true`を返す,`nil`を返す,NoMethodErrorとなる。,,,,,,,
Ruby,Date,"```ruby
require ""date""

puts Date.new(2025, 4, 1) + 1
```",2025-04-02,"
Rubyの演算子 + は、メソッドです。
本問では、Date#+ というメソッドが呼ばれ、
引数の1を日数として足しています。",2,2026-04-01,2025-05-01,NoMethodError,,,,,,,
Ruby,reduce,"```ruby
[].reduce(1, 2, 3)
```

このコードを実行すると、次のようなエラー文が表示されます。

```
Main.rb:1:in `reduce': wrong number of arguments (given 3, expected 0..2) (ArgumentError)
        from Main.rb:1:in `<main>'
```

このエラー文の意味として、相応しいものを選びなさい。",`reduce`メソッドの引数の数が誤っている(引数が3個与えられたが、期待している個数は0個から2個だった),単純なエラー文ですね,2,`reduce`というメソッドは存在しない。,`reduce`メソッドの引数の数が誤っている(引数に3が与えられた、期待は0から2だった),`reduce`メソッドの引数の数が誤っている(引数が3個与えられたが、期待している個数は0個から1個だった),,,,,,,
Ruby,Array#zip,"```ruby
p [1, 2].zip([:a, :b, :c])
p [1, 2, 3].zip([:a, :b])```","```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [2, :b]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [2, :b], [3, nil]]
```",zipが、ジッパー(ファスナー)で締めるという意味の英単語です。,1,"```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [2, :b]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [2, :b]]
```","```ruby
p [1, 2].zip([:a, :b, :c]) #=> [[1, :a], [1, :b], [1, :c], [2, :a], [2, :b], [2, :c]]
p [1, 2, 3].zip([:a, :b])  #=> [[1, :a], [1, :b], [2, :a], [2, :b], [3, :a], [3, :b]]
```",エラーになる,,,,,,,
Ruby,Array#product,"```ruby
p [1, 2].product([:a, :b])
```","`[[1, :a], [1, :b], [2, :a], [2, :b]]`",productは積という意味です。集合どうしの積を求めています。,1,"`[[1, :a], [2, :b]]`",TypeErrorになる,NoMethodErrorになる,,,,,,,
Ruby,Hash#except,"```ruby
h = { name: ""Hara"", age: 20, score: 90 }
p h.except(:name, :address)
p h
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> {:age=>20, :score=>0}
p h #=> {:name=>""Hara"", :age=>20, :score=>0}
```","Rails(のActiveSupport)にあった機能ですが、
Ruby 3.0(2020年12月リリース)でRubyコアに組み込まれました。

Hash#deleteを使えば、引数にキーをとって破壊的に削除できましたが、破壊的に削除してしまうので、元の形のまま再利用できませんでした。",1,"```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> {:name=>""Hara""}
p h #=> {:age=>20, :score=>0}
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> [""Hara"", nil]
p h #=> {:age=>20, :score=>0}
```","```ruby
h = { name: ""Hara"", age: 20, score: 0 }
p h.except(:name, :address) #=> [""Hara"", nil]
p h #=> {:name=>""Hara"", :age=>20, :score=>0}
```",,,,,,,
Ruby,ancestors,"`Object`クラスの親クラス(`superclass`)は、`BasicObject`です。
さて、下記のコードを実行すると、どうなりますか。
```ruby
p Object.ancestors
```","`[Object, Kernel, BasicObject]`",,3,`[BasicObject]`,"`[Object, BasicObject]`","`[Kernel, BasicObject]`",,,,,,,
Ruby,super,"```ruby
class ParentCounter
  def initialize
    @cnt = 0
  end

  def count
    @cnt += 1
  end
end

class ChildCounter < ParentCounter
  def count
    super
    @cnt += 1
  end
end

counter = ChildCounter.new
p counter.count
```
何が表示されますか。あるいは、エラーが発生しますか。",2,"ChildCounter.new で 、継承している親の initialize が呼ばれ、@cnt 変数が0 のChildCounterインスタンスができます。
次に、counter.count で、ChildCounter#count が呼ばれ、この中に super があるので、",2,0,1,エラーとなる,,,,,,,
Ruby,Date,今日の日付を知る方法として、選択肢の中から最も適切なものはどれでしょうか。,"```ruby
require ""date""
Date.today
```","今日の日付を知りたいとき、`Date.today`を用います。
`now`クラスメソッドがあるのは、`DateTime`クラスや`Time`クラスです。",2,"```ruby
require ""date""
Date.new
```","```ruby
require ""date""
Date.now
```","```ruby
require ""date""
Date.commercial
```",,,,,,,
Ruby,定数探索,"```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST
    p Foo::CONST
    p ::CONST
    p ::Foo::CONST
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 2
    p ::CONST        #=> 0
    p ::Foo::CONST #=> 1
  end
end
```","いま、`::CONST`に`0`, `::Foo::CONST`に`1`, `::Foo::Foo::CONST`に`2`が代入されます。
`::`始まりはトップレベルを指しており、絶対参照のようなものです。
`Foo`が2つある点に注意してください。
トップレベルで定義される`Foo`と、その中で定義される`Foo`です。

単に`CONST`と書かれている場合、自分の階層から順に探していくので、`2`を返します。
次に`Foo::CONST`で、`Foo`自身も定数として、内側の階層から探し、`Foo::Foo`が見つかるので、その中の`CONST`定数を探し、`2`を返します。",2,"```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 1
    p ::CONST        #=> 2
    p ::Foo::CONST #=> 0
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 2
    p Foo::CONST #=> 2
    p ::CONST        #=> 2
    p ::Foo::CONST #=> 0
  end
end
```","```ruby
CONST = 0

module Foo
  CONST = 1
  module Foo
    CONST = 2
    p CONST          #=> 0
    p Foo::CONST #=> 1
    p ::CONST        #=>  2
    p ::Foo::CONST #=> 2
  end
end
```",,,,,,,
Ruby,$0と__FILE__,"いま、`main.rb`と`sub.rb`が同一のホームディレクトリ`/Users/aya`にあります。

`main.rb`では、`sub.rb`を実行(ロード)するだけです。
```ruby
require_relative ""./sub""
```

`sub.rb`で出力します。何が出力されますか。
```ruby
p $0
p __FILE__
```

なお、同一のホームディレクトリからコマンドを実行するものとします。","```ruby
p $0          #=> ""main.rb""
p __FILE__ #=> ""/User/aya/sub.rb""
```",,1,"```ruby
p $0          #=> ""main.rb""
p __FILE__ #=> ""main.rb""
```","```ruby
p $0          #=> ""/User/aya/sub.rb""
p __FILE__ #=> ""/User/aya/sub.rb""
```",エラーとなる。,,,,,,,
Ruby,累乗の余り,9の987654321乗を1000000007で割った余りを求める方法として適切なものはどれでしょうか。,"`9.pow(98765432, 1000000007)`","xのy乗を求めるとき、`x ** y`か`x.pow(y)`と書きます。
さらに、このようなxのy乗をmで割った余りを求めるときは、`x.pow(y, m)`と書きます。

`x ** y % m`と`x.pow(y) % m`と書いて実行すると、累乗の計算の段階で巨大な数となり計算結果が`Float::INFINITY`等になり、`%`で割ることで",2,`9 ** 987654321 % 1000000007`,"`pow(9, 98765432, 1000000007)`",`9.pow(98765432) % 1000000007`,,,,,,,
Ruby,複数の可変長引数,"```ruby
def foo(*x, y, *z)
  p y
end
```
上記のコードは、定義できますか。",できない,"```ruby
def f(x, *a)
  a
end

p f(3, :dog, :cat) # => [:dog, :cat]
```
メソッドの定義で、引数の変数に * があるものは可変長引数です。
可変長引数は、複数の引数を受け取って、配列とします。

もし複数の可変長引数を定義しようとすると構文エラー(syntax error)になります。
可変長引数が複数あると、どの部分が可変長引数かわからなくなるので定義できない、と捉えるとよいでしょう。",1,できる,,,,,,,,,
Ruby,先頭の可変長引数,"```ruby
def f1(*a, x)
  p a
end
```
上記のコードは、定義できますか。",できる,"```ruby
def f1(*a, x)
  p a
end

f1(1, 2, 3, :smith) #=> [1, 2, 3]
```
メソッドの定義で、引数の変数に * があるものは可変長引数です。
一般に、可変長引数は、通常の引数の後ろに書きますが、通常の引数の先に書くこともできます。
",0,できない,,,,,,,,,
Ruby,単語数,"```ruby
s = ""ruby ruby python crystal rust""
```

文字列の中の ""ruby"" という単語を数えるときに使うStringのインスタンスメソッドはどれですか。","```ruby
s = ""ruby ruby python crystal rust""
p s.scan(""ruby"").size
```","```ruby
s = ""ruby ruby crystal ruby""
p s.count(""ruby"") #=> 14
p s.index(""ruby"") #=> 0
p s.scan(""ruby"") #=> [""ruby"", ""ruby"", ""ruby""]
p s.scan(""ruby"").size #=> 3
```

String#count は、引数のそれぞれの文字を数えます。
rが4文字, uが3文字、bが3文字、yが4文字で、合計14文字。

String#count は、引数が最初にあった位置を返します。
0番目に ruby があるので、0番目を返します。

String#scan は、引数がマッチした部分文字列を配列にして返します。",3,"```ruby
s = ""ruby ruby python crystal rust""
p s.count(""ruby"")
```","```ruby
s = ""ruby ruby python crystal rust""
p s.index(""ruby"")
```","```ruby
s = ""ruby ruby python crystal rust""
p s.scan(""ruby"") 
```",,,,,,,
Ruby,ようかんの各長さ(差分),"競プロ典型90問

下記の設問の答えとして誤っているものはどれか。

ようかんの長さがLです。
切れ目がN個あり、0 < d_1 < d_2 < d_3 < d_N < L で与えられます。
全ての箇所で切ったときの、N + 1個のようかんのそれぞれの長さを求めなさい。

L = 34
d = [8, 13, 26]","```rb
d.push(L)
d.unshift(0)
d.each_slice(2).map{ _2 - _1 }
```",each_consを使わない方法がちょっと速いかもしれない。,3,"```rb
d << L
d.unshift(0)
p d.each_cons(2).map{ |x, y| y - x }
```","```rb
d.push(L)
d.unshift(0)
p d.each_cons(2).map{ _2 - _1 }
```","```rb
d << L
s = 0
d.map{ t = s;  s = _1; _1 - t }
```",,,,,,,